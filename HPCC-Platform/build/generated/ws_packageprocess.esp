// *** Source file generated by HIDL Version 1.3 from ws_packageprocess.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_packageprocess_ESPGEN_INCLUDED
#define ws_packageprocess_ESPGEN_INCLUDED

#include "ws_packageprocess_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CEchoRequest Implementation
//=======================================================

CEchoRequest::CEchoRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEchoRequest::CEchoRequest(const char *serviceName, const char *bc)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
}

CEchoRequest::CEchoRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CEchoRequest::CEchoRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Request(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEchoRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Request\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEchoRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEchoRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEchoRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Request");
	form.appendf("  <tr><td><b>Request: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEchoRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEchoRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Request.marshall(rpc_resp, "Request", "", "", "");
}


void CEchoRequest::copy(CEchoRequest &from)
{
	m_Request.copy(from.m_Request);
}


void CEchoRequest::copy(IConstEchoRequest &ifrom)
{
	setRequest(ifrom.getRequest());
}


void CEchoRequest::getAttributes(IProperties &attributes)
{
}


void CEchoRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Request.toStr(ctx, buffer, "Request", "", true, "", "");
}


void CEchoRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEchoRequest::serializer(IEspContext* ctx, IConstEchoRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EchoRequest>");
	// field Request
	{
		const char* s = src.getRequest();
		if (s && *s)
		{
			buffer.append("<Request>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Request>");
		}
	}
	if (keepRootTag)
		buffer.append("</EchoRequest>");
}

bool CEchoRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Request.unmarshall(rpc_request, "Request", basepath);
	return hasValue;
}

bool CEchoRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Request.unmarshall(ctx, soapval, "Request");
	return hasValue;
}

bool CEchoRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Request.unmarshall(ctx, params, attachments, "Request", basepath);
	return hasValue;
}

const char * CEchoRequest::getRequest() { return m_Request.query();}
void CEchoRequest::setRequest(const char * val){ m_Request.set(val); }
extern "C"  IEspEchoRequest *createEchoRequest(const char *serv){return ((IEspEchoRequest *)new CEchoRequest(serv));}
extern "C"  IClientEchoRequest *createClientEchoRequest(const char *serv){return ((IClientEchoRequest *)new CEchoRequest(serv));}

//=======================================================
// class CEchoResponse Implementation
//=======================================================

CEchoResponse::CEchoResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CEchoResponse::CEchoResponse(const char *serviceName, const char *bc)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
}

CEchoResponse::CEchoResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CEchoResponse::CEchoResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Response(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("EchoResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CEchoResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Response\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CEchoResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CEchoResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CEchoResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Response");
	form.appendf("  <tr><td><b>Response: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CEchoResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CEchoResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_Response.marshall(rpc_resp, "Response", "", "", "");
	}
}


void CEchoResponse::copy(CEchoResponse &from)
{
	m_Response.copy(from.m_Response);
}


void CEchoResponse::copy(IConstEchoResponse &ifrom)
{
	setResponse(ifrom.getResponse());
}


void CEchoResponse::getAttributes(IProperties &attributes)
{
}


void CEchoResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_Response.toStr(ctx, buffer, "Response", "", true, "", "");
	}
}


void CEchoResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CEchoResponse::serializer(IEspContext* ctx, IConstEchoResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<EchoResponse>");
	// field Response
	{
		const char* s = src.getResponse();
		if (s && *s)
		{
			buffer.append("<Response>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Response>");
		}
	}
	if (keepRootTag)
		buffer.append("</EchoResponse>");
}

bool CEchoResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_Response.unmarshall(rpc_request, "Response", basepath);
	}
	return hasValue;
}

bool CEchoResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Response.unmarshall(ctx, soapval, "Response");
	return hasValue;
}

bool CEchoResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Response.unmarshall(ctx, params, attachments, "Response", basepath);
	return hasValue;
}

const char * CEchoResponse::getResponse() { return m_Response.query();}
void CEchoResponse::setResponse(const char * val){ m_Response.set(val); }
extern "C"  IEspEchoResponse *createEchoResponse(const char *serv){return ((IEspEchoResponse *)new CEchoResponse(serv));}
extern "C"  IClientEchoResponse *createClientEchoResponse(const char *serv){return ((IClientEchoResponse *)new CEchoResponse(serv));}

//=======================================================
// class CBasePackageStatus Implementation
//=======================================================

CBasePackageStatus::CBasePackageStatus(const char *serviceName, IRpcMessageBinding *init)
	: m_Code(nilIgnore),m_Description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasePackageStatus");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CBasePackageStatus::CBasePackageStatus(const char *serviceName, const char *bc)
	: m_Code(nilIgnore),m_Description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("BasePackageStatus");
}

StringBuffer &CBasePackageStatus::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Code\" type=\"xsd:int\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CBasePackageStatus::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CBasePackageStatus::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CBasePackageStatus::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix) extfix.append(prefix).append(".");
		extfix.append("Code");
	form.appendf("  <tr><td><b>Code: </b></td><td><input type=\"text\" name=\"%s\" size=\"20\"/>", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Description");
	form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CBasePackageStatus::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CBasePackageStatus::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Code.marshall(rpc_resp, "Code", "", "", "");
	m_Description.marshall(rpc_resp, "Description", "", "", "");
}


void CBasePackageStatus::copy(CBasePackageStatus &from)
{
	m_Code.copy(from.m_Code);
	m_Description.copy(from.m_Description);
}


void CBasePackageStatus::copy(IConstBasePackageStatus &ifrom)
{
	setCode(ifrom.getCode());
	setDescription(ifrom.getDescription());
}


void CBasePackageStatus::getAttributes(IProperties &attributes)
{
}


void CBasePackageStatus::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Code.toStr(ctx, buffer, "Code", "", true, "", "");
	m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
}


void CBasePackageStatus::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CBasePackageStatus::serializer(IEspContext* ctx, IConstBasePackageStatus &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<BasePackageStatus>");
	// field Code
	{
		int n = src.getCode();
		if (n)
			buffer.appendf("<Code>%d</Code>", n);
	}
	// field Description
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	if (keepRootTag)
		buffer.append("</BasePackageStatus>");
}

bool CBasePackageStatus::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Code.unmarshall(rpc_request, "Code", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	return hasValue;
}

bool CBasePackageStatus::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Code.unmarshall(ctx, soapval, "Code");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	return hasValue;
}

bool CBasePackageStatus::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Code.unmarshall(ctx, params, attachments, "Code", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	return hasValue;
}

int CBasePackageStatus::getCode() { return m_Code;}
const char * CBasePackageStatus::getDescription() { return m_Description.query();}
void CBasePackageStatus::setCode(int val){ m_Code=val; }
void CBasePackageStatus::setDescription(const char * val){ m_Description.set(val); }
extern "C"  IEspBasePackageStatus *createBasePackageStatus(const char *serv, const char *msgname){return ((IEspBasePackageStatus *)new CBasePackageStatus(serv /*, msgname*/));}
extern "C"  IClientBasePackageStatus *createClientBasePackageStatus(const char *serv, const char *msgname){return ((IClientBasePackageStatus *)new CBasePackageStatus(serv /*, msgname*/));}

//=======================================================
// class CPackageMapEntry Implementation
//=======================================================

CPackageMapEntry::CPackageMapEntry(const char *serviceName, IRpcMessageBinding *init)
	: m_Id(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PackageMapEntry");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPackageMapEntry::CPackageMapEntry(const char *serviceName, const char *bc)
	: m_Id(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PackageMapEntry");
}

StringBuffer &CPackageMapEntry::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Id\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CPackageMapEntry::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPackageMapEntry::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CPackageMapEntry::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Id");
	form.appendf("  <tr><td><b>Id: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPackageMapEntry::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPackageMapEntry::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Id.marshall(rpc_resp, "Id", "", "", "");
	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
}


void CPackageMapEntry::copy(CPackageMapEntry &from)
{
	m_Id.copy(from.m_Id);
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
}


void CPackageMapEntry::copy(IConstPackageMapEntry &ifrom)
{
	setId(ifrom.getId());
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
}


void CPackageMapEntry::getAttributes(IProperties &attributes)
{
}


void CPackageMapEntry::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Id.toStr(ctx, buffer, "Id", "", true, "", "");
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
}


void CPackageMapEntry::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPackageMapEntry::serializer(IEspContext* ctx, IConstPackageMapEntry &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PackageMapEntry>");
	// field Id
	{
		const char* s = src.getId();
		if (s && *s)
		{
			buffer.append("<Id>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Id>");
		}
	}
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	if (keepRootTag)
		buffer.append("</PackageMapEntry>");
}

bool CPackageMapEntry::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(rpc_request, "Id", basepath);
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	return hasValue;
}

bool CPackageMapEntry::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, soapval, "Id");
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	return hasValue;
}

bool CPackageMapEntry::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, params, attachments, "Id", basepath);
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	return hasValue;
}

const char * CPackageMapEntry::getId() { return m_Id.query();}
const char * CPackageMapEntry::getTarget() { return m_Target.query();}
const char * CPackageMapEntry::getProcess() { return m_Process.query();}
void CPackageMapEntry::setId(const char * val){ m_Id.set(val); }
void CPackageMapEntry::setTarget(const char * val){ m_Target.set(val); }
void CPackageMapEntry::setProcess(const char * val){ m_Process.set(val); }
extern "C"  IEspPackageMapEntry *createPackageMapEntry(const char *serv, const char *msgname){return ((IEspPackageMapEntry *)new CPackageMapEntry(serv /*, msgname*/));}
extern "C"  IClientPackageMapEntry *createClientPackageMapEntry(const char *serv, const char *msgname){return ((IClientPackageMapEntry *)new CPackageMapEntry(serv /*, msgname*/));}

//=======================================================
// class CAddPackageRequest Implementation
//=======================================================

CAddPackageRequest::CAddPackageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Info(nilIgnore),m_Activate(nilIgnore),m_OverWrite(nilIgnore),m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddPackageRequest::CAddPackageRequest(const char *serviceName, const char *bc)
	: m_Info(nilIgnore),m_Activate(nilIgnore),m_OverWrite(nilIgnore),m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageRequest");
}

CAddPackageRequest::CAddPackageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Info(nilIgnore),m_Activate(nilIgnore),m_OverWrite(nilIgnore),m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddPackageRequest::CAddPackageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Info(nilIgnore),m_Activate(nilIgnore),m_OverWrite(nilIgnore),m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddPackageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Info\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Activate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"OverWrite\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMap\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DaliIp\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceProcess\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"AllowForeignFiles\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("AddPackageRequest","PreloadAllPackages")) {
			schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"PreloadAllPackages\" type=\"xsd:boolean\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ReplacePackageMap\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UpdateSuperFiles\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UpdateCloneFrom\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"AppendCluster\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddPackageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddPackageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("AddPackageRequest","PreloadAllPackages",1.02);
}

StringBuffer &CAddPackageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Info");
	form.appendf("  <tr><td><b>Info: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Activate");
	
	form.appendf("  <tr><td><b>Activate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("OverWrite");
	
	form.appendf("  <tr><td><b>OverWrite? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMap");
	form.appendf("  <tr><td><b>PackageMap: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DaliIp");
	form.appendf("  <tr><td><b>DaliIp: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceProcess");
	form.appendf("  <tr><td><b>SourceProcess: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AllowForeignFiles");
	
	form.appendf("  <tr><td><b>AllowForeignFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (!context.suppressed("AddPackageRequest","PreloadAllPackages")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("PreloadAllPackages");
		
	form.appendf("  <tr><td><b>PreloadAllPackages? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReplacePackageMap");
	
	form.appendf("  <tr><td><b>ReplacePackageMap? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateSuperFiles");
	
	form.appendf("  <tr><td><b>UpdateSuperFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateCloneFrom");
	
	form.appendf("  <tr><td><b>UpdateCloneFrom? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AppendCluster");
	
	form.appendf("  <tr><td><b>AppendCluster? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddPackageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddPackageRequest::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Info.marshall(rpc_resp, "Info", "", "", "");
	m_Activate.marshall(rpc_resp, "Activate", "", "", "");
	m_OverWrite.marshall(rpc_resp, "OverWrite", "", "", "");
	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_PackageMap.marshall(rpc_resp, "PackageMap", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_DaliIp.marshall(rpc_resp, "DaliIp", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
	m_SourceProcess.marshall(rpc_resp, "SourceProcess", "", "", "");
	m_AllowForeignFiles.marshall(rpc_resp, "AllowForeignFiles", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_PreloadAllPackages.marshall(rpc_resp, "PreloadAllPackages", "", "", "");
	m_ReplacePackageMap.marshall(rpc_resp, "ReplacePackageMap", "", "", "");
	m_UpdateSuperFiles.marshall(rpc_resp, "UpdateSuperFiles", "", "", "");
	m_UpdateCloneFrom.marshall(rpc_resp, "UpdateCloneFrom", "", "", "");
	m_AppendCluster.marshall(rpc_resp, "AppendCluster", "", "", "");
}


void CAddPackageRequest::copy(CAddPackageRequest &from)
{
	m_Info.copy(from.m_Info);
	m_Activate.copy(from.m_Activate);
	m_OverWrite.copy(from.m_OverWrite);
	m_Target.copy(from.m_Target);
	m_PackageMap.copy(from.m_PackageMap);
	m_Process.copy(from.m_Process);
	m_DaliIp.copy(from.m_DaliIp);
	m_GlobalScope.copy(from.m_GlobalScope);
	m_SourceProcess.copy(from.m_SourceProcess);
	m_AllowForeignFiles.copy(from.m_AllowForeignFiles);
	m_PreloadAllPackages.copy(from.m_PreloadAllPackages);
	m_ReplacePackageMap.copy(from.m_ReplacePackageMap);
	m_UpdateSuperFiles.copy(from.m_UpdateSuperFiles);
	m_UpdateCloneFrom.copy(from.m_UpdateCloneFrom);
	m_AppendCluster.copy(from.m_AppendCluster);
}


void CAddPackageRequest::copy(IConstAddPackageRequest &ifrom)
{
	setInfo(ifrom.getInfo());
	setActivate(ifrom.getActivate());
	setOverWrite(ifrom.getOverWrite());
	setTarget(ifrom.getTarget());
	setPackageMap(ifrom.getPackageMap());
	setProcess(ifrom.getProcess());
	setDaliIp(ifrom.getDaliIp());
	setGlobalScope(ifrom.getGlobalScope());
	setSourceProcess(ifrom.getSourceProcess());
	setAllowForeignFiles(ifrom.getAllowForeignFiles());
	setPreloadAllPackages(ifrom.getPreloadAllPackages());
	setReplacePackageMap(ifrom.getReplacePackageMap());
	setUpdateSuperFiles(ifrom.getUpdateSuperFiles());
	setUpdateCloneFrom(ifrom.getUpdateCloneFrom());
	setAppendCluster(ifrom.getAppendCluster());
}


void CAddPackageRequest::getAttributes(IProperties &attributes)
{
}


void CAddPackageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Info.toStr(ctx, buffer, "Info", "", true, "", "");
	m_Activate.toStr(ctx, buffer, "Activate", "", true, "", "");
	m_OverWrite.toStr(ctx, buffer, "OverWrite", "", true, "", "");
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_PackageMap.toStr(ctx, buffer, "PackageMap", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_DaliIp.toStr(ctx, buffer, "DaliIp", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
	m_SourceProcess.toStr(ctx, buffer, "SourceProcess", "", true, "", "");
	m_AllowForeignFiles.toStr(ctx, buffer, "AllowForeignFiles", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.02))
		m_PreloadAllPackages.toStr(ctx, buffer, "PreloadAllPackages", "", true, "", "");
	m_ReplacePackageMap.toStr(ctx, buffer, "ReplacePackageMap", "", true, "", "");
	m_UpdateSuperFiles.toStr(ctx, buffer, "UpdateSuperFiles", "", true, "", "");
	m_UpdateCloneFrom.toStr(ctx, buffer, "UpdateCloneFrom", "", true, "", "");
	m_AppendCluster.toStr(ctx, buffer, "AppendCluster", "", true, "", "");
}


void CAddPackageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddPackageRequest::serializer(IEspContext* ctx, IConstAddPackageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddPackageRequest>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Info
	{
		const char* s = src.getInfo();
		if (s && *s)
		{
			buffer.append("<Info>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Info>");
		}
	}
	// field Activate
	{
		bool b = src.getActivate();
		if (b)
			buffer.appendf("<Activate>1</Activate>");
	}
	// field OverWrite
	{
		bool b = src.getOverWrite();
		if (b)
			buffer.appendf("<OverWrite>1</OverWrite>");
	}
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field PackageMap
	{
		const char* s = src.getPackageMap();
		if (s && *s)
		{
			buffer.append("<PackageMap>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMap>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field DaliIp
	{
		const char* s = src.getDaliIp();
		if (s && *s)
		{
			buffer.append("<DaliIp>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DaliIp>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	// field SourceProcess
	{
		const char* s = src.getSourceProcess();
		if (s && *s)
		{
			buffer.append("<SourceProcess>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceProcess>");
		}
	}
	// field AllowForeignFiles
	{
		bool b = src.getAllowForeignFiles();
		if (b)
			buffer.appendf("<AllowForeignFiles>1</AllowForeignFiles>");
	}
	// field PreloadAllPackages
	if ((clientVer==-1.0 || clientVer>=1.02))
	{
		bool b = src.getPreloadAllPackages();
		if (b)
			buffer.appendf("<PreloadAllPackages>1</PreloadAllPackages>");
	}
	// field ReplacePackageMap
	{
		bool b = src.getReplacePackageMap();
		if (b)
			buffer.appendf("<ReplacePackageMap>1</ReplacePackageMap>");
	}
	// field UpdateSuperFiles
	{
		bool b = src.getUpdateSuperFiles();
		if (b)
			buffer.appendf("<UpdateSuperFiles>1</UpdateSuperFiles>");
	}
	// field UpdateCloneFrom
	{
		bool b = src.getUpdateCloneFrom();
		if (b)
			buffer.appendf("<UpdateCloneFrom>1</UpdateCloneFrom>");
	}
	// field AppendCluster
	{
		bool b = src.getAppendCluster();
		if (b)
			buffer.appendf("<AppendCluster>1</AppendCluster>");
	}
	if (keepRootTag)
		buffer.append("</AddPackageRequest>");
}

bool CAddPackageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Info.unmarshall(rpc_request, "Info", basepath);
	hasValue |= m_Activate.unmarshall(rpc_request, "Activate", basepath);
	hasValue |= m_OverWrite.unmarshall(rpc_request, "OverWrite", basepath);
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(rpc_request, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_DaliIp.unmarshall(rpc_request, "DaliIp", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	hasValue |= m_SourceProcess.unmarshall(rpc_request, "SourceProcess", basepath);
	hasValue |= m_AllowForeignFiles.unmarshall(rpc_request, "AllowForeignFiles", basepath);
	hasValue |= m_PreloadAllPackages.unmarshall(rpc_request, "PreloadAllPackages", basepath);
	hasValue |= m_ReplacePackageMap.unmarshall(rpc_request, "ReplacePackageMap", basepath);
	hasValue |= m_UpdateSuperFiles.unmarshall(rpc_request, "UpdateSuperFiles", basepath);
	hasValue |= m_UpdateCloneFrom.unmarshall(rpc_request, "UpdateCloneFrom", basepath);
	hasValue |= m_AppendCluster.unmarshall(rpc_request, "AppendCluster", basepath);
	return hasValue;
}

bool CAddPackageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Info.unmarshall(ctx, soapval, "Info");
	hasValue |= m_Activate.unmarshall(ctx, soapval, "Activate");
	hasValue |= m_OverWrite.unmarshall(ctx, soapval, "OverWrite");
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_PackageMap.unmarshall(ctx, soapval, "PackageMap");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_DaliIp.unmarshall(ctx, soapval, "DaliIp");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	hasValue |= m_SourceProcess.unmarshall(ctx, soapval, "SourceProcess");
	hasValue |= m_AllowForeignFiles.unmarshall(ctx, soapval, "AllowForeignFiles");
	hasValue |= m_PreloadAllPackages.unmarshall(ctx, soapval, "PreloadAllPackages");
	hasValue |= m_ReplacePackageMap.unmarshall(ctx, soapval, "ReplacePackageMap");
	hasValue |= m_UpdateSuperFiles.unmarshall(ctx, soapval, "UpdateSuperFiles");
	hasValue |= m_UpdateCloneFrom.unmarshall(ctx, soapval, "UpdateCloneFrom");
	hasValue |= m_AppendCluster.unmarshall(ctx, soapval, "AppendCluster");
	return hasValue;
}

bool CAddPackageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Info.unmarshall(ctx, params, attachments, "Info", basepath);
	hasValue |= m_Activate.unmarshall(ctx, params, attachments, "Activate", basepath);
	hasValue |= m_OverWrite.unmarshall(ctx, params, attachments, "OverWrite", basepath);
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(ctx, params, attachments, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_DaliIp.unmarshall(ctx, params, attachments, "DaliIp", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	hasValue |= m_SourceProcess.unmarshall(ctx, params, attachments, "SourceProcess", basepath);
	hasValue |= m_AllowForeignFiles.unmarshall(ctx, params, attachments, "AllowForeignFiles", basepath);
	hasValue |= m_PreloadAllPackages.unmarshall(ctx, params, attachments, "PreloadAllPackages", basepath);
	hasValue |= m_ReplacePackageMap.unmarshall(ctx, params, attachments, "ReplacePackageMap", basepath);
	hasValue |= m_UpdateSuperFiles.unmarshall(ctx, params, attachments, "UpdateSuperFiles", basepath);
	hasValue |= m_UpdateCloneFrom.unmarshall(ctx, params, attachments, "UpdateCloneFrom", basepath);
	hasValue |= m_AppendCluster.unmarshall(ctx, params, attachments, "AppendCluster", basepath);
	return hasValue;
}

const char * CAddPackageRequest::getInfo() { return m_Info.query();}
bool CAddPackageRequest::getActivate() { return m_Activate;}
bool CAddPackageRequest::getOverWrite() { return m_OverWrite;}
const char * CAddPackageRequest::getTarget() { return m_Target.query();}
const char * CAddPackageRequest::getPackageMap() { return m_PackageMap.query();}
const char * CAddPackageRequest::getProcess() { return m_Process.query();}
const char * CAddPackageRequest::getDaliIp() { return m_DaliIp.query();}
bool CAddPackageRequest::getGlobalScope() { return m_GlobalScope;}
const char * CAddPackageRequest::getSourceProcess() { return m_SourceProcess.query();}
bool CAddPackageRequest::getAllowForeignFiles() { return m_AllowForeignFiles;}
bool CAddPackageRequest::getPreloadAllPackages() { return m_PreloadAllPackages;}
bool CAddPackageRequest::getReplacePackageMap() { return m_ReplacePackageMap;}
bool CAddPackageRequest::getUpdateSuperFiles() { return m_UpdateSuperFiles;}
bool CAddPackageRequest::getUpdateCloneFrom() { return m_UpdateCloneFrom;}
bool CAddPackageRequest::getAppendCluster() { return m_AppendCluster;}
void CAddPackageRequest::setInfo(const char * val){ m_Info.set(val); }
void CAddPackageRequest::setActivate(bool val){ m_Activate=val; }
void CAddPackageRequest::setOverWrite(bool val){ m_OverWrite=val; }
void CAddPackageRequest::setTarget(const char * val){ m_Target.set(val); }
void CAddPackageRequest::setPackageMap(const char * val){ m_PackageMap.set(val); }
void CAddPackageRequest::setProcess(const char * val){ m_Process.set(val); }
void CAddPackageRequest::setDaliIp(const char * val){ m_DaliIp.set(val); }
void CAddPackageRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
void CAddPackageRequest::setSourceProcess(const char * val){ m_SourceProcess.set(val); }
void CAddPackageRequest::setAllowForeignFiles(bool val){ m_AllowForeignFiles=val; }
void CAddPackageRequest::setPreloadAllPackages(bool val){ m_PreloadAllPackages=val; }
void CAddPackageRequest::setReplacePackageMap(bool val){ m_ReplacePackageMap=val; }
void CAddPackageRequest::setUpdateSuperFiles(bool val){ m_UpdateSuperFiles=val; }
void CAddPackageRequest::setUpdateCloneFrom(bool val){ m_UpdateCloneFrom=val; }
void CAddPackageRequest::setAppendCluster(bool val){ m_AppendCluster=val; }
extern "C"  IEspAddPackageRequest *createAddPackageRequest(const char *serv){return ((IEspAddPackageRequest *)new CAddPackageRequest(serv));}
extern "C"  IClientAddPackageRequest *createClientAddPackageRequest(const char *serv){return ((IClientAddPackageRequest *)new CAddPackageRequest(serv));}

//=======================================================
// class CAddPackageResponse Implementation
//=======================================================

CAddPackageResponse::CAddPackageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddPackageResponse::CAddPackageResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageResponse");
}

CAddPackageResponse::CAddPackageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddPackageResponse::CAddPackageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPackageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddPackageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FilesNotFound\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"File\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CAddPackageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddPackageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CAddPackageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FilesNotFound");
	form.appendf("<tr><td><b>FilesNotFound: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddPackageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddPackageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_FilesNotFound.marshall(rpc_resp, "FilesNotFound", "File");
	}
}


void CAddPackageResponse::copy(CAddPackageResponse &from)
{
	m_status.copy(from.m_status);
	m_FilesNotFound.copy(from.m_FilesNotFound);
}


void CAddPackageResponse::copy(IConstAddPackageResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setFilesNotFound(ifrom.getFilesNotFound());
}


void CAddPackageResponse::getAttributes(IProperties &attributes)
{
}


void CAddPackageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_FilesNotFound.toStr(ctx, buffer, "FilesNotFound", "File");
	}
}


void CAddPackageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddPackageResponse::serializer(IEspContext* ctx, IConstAddPackageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddPackageResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field FilesNotFound
	{
		StringArray& v = src.getFilesNotFound();
		if (v.length()>0)
			buffer.append("<FilesNotFound>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<File>%s</File>",v.item(i));
		if (v.length()>0)
			buffer.append("</FilesNotFound>");
	}
	if (keepRootTag)
		buffer.append("</AddPackageResponse>");
}

bool CAddPackageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_FilesNotFound.unmarshall(rpc_request, "FilesNotFound", basepath);
	}
	return hasValue;
}

bool CAddPackageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_FilesNotFound.unmarshall(ctx, soapval, "FilesNotFound");
	return hasValue;
}

bool CAddPackageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_FilesNotFound.unmarshall(ctx, params, attachments, "FilesNotFound", basepath);
	return hasValue;
}

IConstBasePackageStatus & CAddPackageResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
StringArray & CAddPackageResponse::getFilesNotFound() { return (StringArray &) m_FilesNotFound; }
IEspBasePackageStatus & CAddPackageResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CAddPackageResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CAddPackageResponse::setFilesNotFound(StringArray &val){ m_FilesNotFound->kill();  CloneArray(m_FilesNotFound.getValue(), val); }
extern "C"  IEspAddPackageResponse *createAddPackageResponse(const char *serv){return ((IEspAddPackageResponse *)new CAddPackageResponse(serv));}
extern "C"  IClientAddPackageResponse *createClientAddPackageResponse(const char *serv){return ((IClientAddPackageResponse *)new CAddPackageResponse(serv));}

//=======================================================
// class CCopyPackageMapRequest Implementation
//=======================================================

CCopyPackageMapRequest::CCopyPackageMapRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_SourcePath(nilIgnore),m_RemoteUserName(nilIgnore),m_RemotePassword(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_PMID(nilIgnore),m_Activate(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCopyPackageMapRequest::CCopyPackageMapRequest(const char *serviceName, const char *bc)
	: m_SourcePath(nilIgnore),m_RemoteUserName(nilIgnore),m_RemotePassword(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_PMID(nilIgnore),m_Activate(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapRequest");
}

CCopyPackageMapRequest::CCopyPackageMapRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_SourcePath(nilIgnore),m_RemoteUserName(nilIgnore),m_RemotePassword(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_PMID(nilIgnore),m_Activate(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CCopyPackageMapRequest::CCopyPackageMapRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_SourcePath(nilIgnore),m_RemoteUserName(nilIgnore),m_RemotePassword(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_PMID(nilIgnore),m_Activate(nilIgnore),m_DaliIp(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_SourceProcess(nilIgnore),m_PreloadAllPackages(0, nilIgnore,false),m_ReplacePackageMap(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCopyPackageMapRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourcePath\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"RemoteUserName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"RemotePassword\" type=\"xsd:string\"");
		if (context.queryOptions()&ESPCTX_ALL_ANNOTATION)
			schema.append("> <xsd:annotation><xsd:appinfo><form formType=\"password\"/></xsd:appinfo></xsd:annotation></xsd:element>\n");
		else
			schema.append("/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PMID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Activate\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DaliIp\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceProcess\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"PreloadAllPackages\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"ReplacePackageMap\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UpdateSuperFiles\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UpdateCloneFrom\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"AppendCluster\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CCopyPackageMapRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCopyPackageMapRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CCopyPackageMapRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourcePath");
	form.appendf("  <tr><td><b>SourcePath: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RemoteUserName");
	form.appendf("  <tr><td><b>RemoteUserName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("RemotePassword");
	form.appendf("  <tr><td><b>RemotePassword: </b></td><td><input type=\"password\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PMID");
	form.appendf("  <tr><td><b>PMID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Activate");
	
	form.appendf("  <tr><td><b>Activate? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DaliIp");
	form.appendf("  <tr><td><b>DaliIp: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceProcess");
	form.appendf("  <tr><td><b>SourceProcess: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PreloadAllPackages");
	
	form.appendf("  <tr><td><b>PreloadAllPackages? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReplacePackageMap");
	
	form.appendf("  <tr><td><b>ReplacePackageMap? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateSuperFiles");
	
	form.appendf("  <tr><td><b>UpdateSuperFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateCloneFrom");
	
	form.appendf("  <tr><td><b>UpdateCloneFrom? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AppendCluster");
	
	form.appendf("  <tr><td><b>AppendCluster? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCopyPackageMapRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCopyPackageMapRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_SourcePath.marshall(rpc_resp, "SourcePath", "", "", "");
	m_RemoteUserName.marshall(rpc_resp, "RemoteUserName", "", "", "");
	m_RemotePassword.marshall(rpc_resp, "RemotePassword", "", "", "");
	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_PMID.marshall(rpc_resp, "PMID", "", "", "");
	m_Activate.marshall(rpc_resp, "Activate", "", "", "");
	m_DaliIp.marshall(rpc_resp, "DaliIp", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
	m_SourceProcess.marshall(rpc_resp, "SourceProcess", "", "", "");
	m_PreloadAllPackages.marshall(rpc_resp, "PreloadAllPackages", "", "", "");
	m_ReplacePackageMap.marshall(rpc_resp, "ReplacePackageMap", "", "", "");
	m_UpdateSuperFiles.marshall(rpc_resp, "UpdateSuperFiles", "", "", "");
	m_UpdateCloneFrom.marshall(rpc_resp, "UpdateCloneFrom", "", "", "");
	m_AppendCluster.marshall(rpc_resp, "AppendCluster", "", "", "");
}


void CCopyPackageMapRequest::copy(CCopyPackageMapRequest &from)
{
	m_SourcePath.copy(from.m_SourcePath);
	m_RemoteUserName.copy(from.m_RemoteUserName);
	m_RemotePassword.copy(from.m_RemotePassword);
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
	m_PMID.copy(from.m_PMID);
	m_Activate.copy(from.m_Activate);
	m_DaliIp.copy(from.m_DaliIp);
	m_GlobalScope.copy(from.m_GlobalScope);
	m_SourceProcess.copy(from.m_SourceProcess);
	m_PreloadAllPackages.copy(from.m_PreloadAllPackages);
	m_ReplacePackageMap.copy(from.m_ReplacePackageMap);
	m_UpdateSuperFiles.copy(from.m_UpdateSuperFiles);
	m_UpdateCloneFrom.copy(from.m_UpdateCloneFrom);
	m_AppendCluster.copy(from.m_AppendCluster);
}


void CCopyPackageMapRequest::copy(IConstCopyPackageMapRequest &ifrom)
{
	setSourcePath(ifrom.getSourcePath());
	setRemoteUserName(ifrom.getRemoteUserName());
	setRemotePassword(ifrom.getRemotePassword());
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
	setPMID(ifrom.getPMID());
	setActivate(ifrom.getActivate());
	setDaliIp(ifrom.getDaliIp());
	setGlobalScope(ifrom.getGlobalScope());
	setSourceProcess(ifrom.getSourceProcess());
	setPreloadAllPackages(ifrom.getPreloadAllPackages());
	setReplacePackageMap(ifrom.getReplacePackageMap());
	setUpdateSuperFiles(ifrom.getUpdateSuperFiles());
	setUpdateCloneFrom(ifrom.getUpdateCloneFrom());
	setAppendCluster(ifrom.getAppendCluster());
}


void CCopyPackageMapRequest::getAttributes(IProperties &attributes)
{
}


void CCopyPackageMapRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_SourcePath.toStr(ctx, buffer, "SourcePath", "", true, "", "");
	m_RemoteUserName.toStr(ctx, buffer, "RemoteUserName", "", true, "", "");
	m_RemotePassword.toStr(ctx, buffer, "RemotePassword", "", true, "", "");
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_PMID.toStr(ctx, buffer, "PMID", "", true, "", "");
	m_Activate.toStr(ctx, buffer, "Activate", "", true, "", "");
	m_DaliIp.toStr(ctx, buffer, "DaliIp", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
	m_SourceProcess.toStr(ctx, buffer, "SourceProcess", "", true, "", "");
	m_PreloadAllPackages.toStr(ctx, buffer, "PreloadAllPackages", "", true, "", "");
	m_ReplacePackageMap.toStr(ctx, buffer, "ReplacePackageMap", "", true, "", "");
	m_UpdateSuperFiles.toStr(ctx, buffer, "UpdateSuperFiles", "", true, "", "");
	m_UpdateCloneFrom.toStr(ctx, buffer, "UpdateCloneFrom", "", true, "", "");
	m_AppendCluster.toStr(ctx, buffer, "AppendCluster", "", true, "", "");
}


void CCopyPackageMapRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCopyPackageMapRequest::serializer(IEspContext* ctx, IConstCopyPackageMapRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CopyPackageMapRequest>");
	// field SourcePath
	{
		const char* s = src.getSourcePath();
		if (s && *s)
		{
			buffer.append("<SourcePath>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourcePath>");
		}
	}
	// field RemoteUserName
	{
		const char* s = src.getRemoteUserName();
		if (s && *s)
		{
			buffer.append("<RemoteUserName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</RemoteUserName>");
		}
	}
	// field RemotePassword
	{
		const char* s = src.getRemotePassword();
		if (s && *s)
		{
			buffer.append("<RemotePassword>");
			encodeUtf8XML(s,buffer);
			buffer.append("</RemotePassword>");
		}
	}
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field PMID
	{
		const char* s = src.getPMID();
		if (s && *s)
		{
			buffer.append("<PMID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PMID>");
		}
	}
	// field Activate
	{
		bool b = src.getActivate();
		if (b)
			buffer.appendf("<Activate>1</Activate>");
	}
	// field DaliIp
	{
		const char* s = src.getDaliIp();
		if (s && *s)
		{
			buffer.append("<DaliIp>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DaliIp>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	// field SourceProcess
	{
		const char* s = src.getSourceProcess();
		if (s && *s)
		{
			buffer.append("<SourceProcess>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceProcess>");
		}
	}
	// field PreloadAllPackages
	{
		bool b = src.getPreloadAllPackages();
		if (b)
			buffer.appendf("<PreloadAllPackages>1</PreloadAllPackages>");
	}
	// field ReplacePackageMap
	{
		bool b = src.getReplacePackageMap();
		if (b)
			buffer.appendf("<ReplacePackageMap>1</ReplacePackageMap>");
	}
	// field UpdateSuperFiles
	{
		bool b = src.getUpdateSuperFiles();
		if (b)
			buffer.appendf("<UpdateSuperFiles>1</UpdateSuperFiles>");
	}
	// field UpdateCloneFrom
	{
		bool b = src.getUpdateCloneFrom();
		if (b)
			buffer.appendf("<UpdateCloneFrom>1</UpdateCloneFrom>");
	}
	// field AppendCluster
	{
		bool b = src.getAppendCluster();
		if (b)
			buffer.appendf("<AppendCluster>1</AppendCluster>");
	}
	if (keepRootTag)
		buffer.append("</CopyPackageMapRequest>");
}

bool CCopyPackageMapRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_SourcePath.unmarshall(rpc_request, "SourcePath", basepath);
	hasValue |= m_RemoteUserName.unmarshall(rpc_request, "RemoteUserName", basepath);
	hasValue |= m_RemotePassword.unmarshall(rpc_request, "RemotePassword", basepath);
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_PMID.unmarshall(rpc_request, "PMID", basepath);
	hasValue |= m_Activate.unmarshall(rpc_request, "Activate", basepath);
	hasValue |= m_DaliIp.unmarshall(rpc_request, "DaliIp", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	hasValue |= m_SourceProcess.unmarshall(rpc_request, "SourceProcess", basepath);
	hasValue |= m_PreloadAllPackages.unmarshall(rpc_request, "PreloadAllPackages", basepath);
	hasValue |= m_ReplacePackageMap.unmarshall(rpc_request, "ReplacePackageMap", basepath);
	hasValue |= m_UpdateSuperFiles.unmarshall(rpc_request, "UpdateSuperFiles", basepath);
	hasValue |= m_UpdateCloneFrom.unmarshall(rpc_request, "UpdateCloneFrom", basepath);
	hasValue |= m_AppendCluster.unmarshall(rpc_request, "AppendCluster", basepath);
	return hasValue;
}

bool CCopyPackageMapRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_SourcePath.unmarshall(ctx, soapval, "SourcePath");
	hasValue |= m_RemoteUserName.unmarshall(ctx, soapval, "RemoteUserName");
	hasValue |= m_RemotePassword.unmarshall(ctx, soapval, "RemotePassword");
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_PMID.unmarshall(ctx, soapval, "PMID");
	hasValue |= m_Activate.unmarshall(ctx, soapval, "Activate");
	hasValue |= m_DaliIp.unmarshall(ctx, soapval, "DaliIp");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	hasValue |= m_SourceProcess.unmarshall(ctx, soapval, "SourceProcess");
	hasValue |= m_PreloadAllPackages.unmarshall(ctx, soapval, "PreloadAllPackages");
	hasValue |= m_ReplacePackageMap.unmarshall(ctx, soapval, "ReplacePackageMap");
	hasValue |= m_UpdateSuperFiles.unmarshall(ctx, soapval, "UpdateSuperFiles");
	hasValue |= m_UpdateCloneFrom.unmarshall(ctx, soapval, "UpdateCloneFrom");
	hasValue |= m_AppendCluster.unmarshall(ctx, soapval, "AppendCluster");
	return hasValue;
}

bool CCopyPackageMapRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_SourcePath.unmarshall(ctx, params, attachments, "SourcePath", basepath);
	hasValue |= m_RemoteUserName.unmarshall(ctx, params, attachments, "RemoteUserName", basepath);
	hasValue |= m_RemotePassword.unmarshall(ctx, params, attachments, "RemotePassword", basepath);
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_PMID.unmarshall(ctx, params, attachments, "PMID", basepath);
	hasValue |= m_Activate.unmarshall(ctx, params, attachments, "Activate", basepath);
	hasValue |= m_DaliIp.unmarshall(ctx, params, attachments, "DaliIp", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	hasValue |= m_SourceProcess.unmarshall(ctx, params, attachments, "SourceProcess", basepath);
	hasValue |= m_PreloadAllPackages.unmarshall(ctx, params, attachments, "PreloadAllPackages", basepath);
	hasValue |= m_ReplacePackageMap.unmarshall(ctx, params, attachments, "ReplacePackageMap", basepath);
	hasValue |= m_UpdateSuperFiles.unmarshall(ctx, params, attachments, "UpdateSuperFiles", basepath);
	hasValue |= m_UpdateCloneFrom.unmarshall(ctx, params, attachments, "UpdateCloneFrom", basepath);
	hasValue |= m_AppendCluster.unmarshall(ctx, params, attachments, "AppendCluster", basepath);
	return hasValue;
}

const char * CCopyPackageMapRequest::getSourcePath() { return m_SourcePath.query();}
const char * CCopyPackageMapRequest::getRemoteUserName() { return m_RemoteUserName.query();}
const char * CCopyPackageMapRequest::getRemotePassword() { return m_RemotePassword.query();}
const char * CCopyPackageMapRequest::getTarget() { return m_Target.query();}
const char * CCopyPackageMapRequest::getProcess() { return m_Process.query();}
const char * CCopyPackageMapRequest::getPMID() { return m_PMID.query();}
bool CCopyPackageMapRequest::getActivate() { return m_Activate;}
const char * CCopyPackageMapRequest::getDaliIp() { return m_DaliIp.query();}
bool CCopyPackageMapRequest::getGlobalScope() { return m_GlobalScope;}
const char * CCopyPackageMapRequest::getSourceProcess() { return m_SourceProcess.query();}
bool CCopyPackageMapRequest::getPreloadAllPackages() { return m_PreloadAllPackages;}
bool CCopyPackageMapRequest::getReplacePackageMap() { return m_ReplacePackageMap;}
bool CCopyPackageMapRequest::getUpdateSuperFiles() { return m_UpdateSuperFiles;}
bool CCopyPackageMapRequest::getUpdateCloneFrom() { return m_UpdateCloneFrom;}
bool CCopyPackageMapRequest::getAppendCluster() { return m_AppendCluster;}
void CCopyPackageMapRequest::setSourcePath(const char * val){ m_SourcePath.set(val); }
void CCopyPackageMapRequest::setRemoteUserName(const char * val){ m_RemoteUserName.set(val); }
void CCopyPackageMapRequest::setRemotePassword(const char * val){ m_RemotePassword.set(val); }
void CCopyPackageMapRequest::setTarget(const char * val){ m_Target.set(val); }
void CCopyPackageMapRequest::setProcess(const char * val){ m_Process.set(val); }
void CCopyPackageMapRequest::setPMID(const char * val){ m_PMID.set(val); }
void CCopyPackageMapRequest::setActivate(bool val){ m_Activate=val; }
void CCopyPackageMapRequest::setDaliIp(const char * val){ m_DaliIp.set(val); }
void CCopyPackageMapRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
void CCopyPackageMapRequest::setSourceProcess(const char * val){ m_SourceProcess.set(val); }
void CCopyPackageMapRequest::setPreloadAllPackages(bool val){ m_PreloadAllPackages=val; }
void CCopyPackageMapRequest::setReplacePackageMap(bool val){ m_ReplacePackageMap=val; }
void CCopyPackageMapRequest::setUpdateSuperFiles(bool val){ m_UpdateSuperFiles=val; }
void CCopyPackageMapRequest::setUpdateCloneFrom(bool val){ m_UpdateCloneFrom=val; }
void CCopyPackageMapRequest::setAppendCluster(bool val){ m_AppendCluster=val; }
extern "C"  IEspCopyPackageMapRequest *createCopyPackageMapRequest(const char *serv){return ((IEspCopyPackageMapRequest *)new CCopyPackageMapRequest(serv));}
extern "C"  IClientCopyPackageMapRequest *createClientCopyPackageMapRequest(const char *serv){return ((IClientCopyPackageMapRequest *)new CCopyPackageMapRequest(serv));}

//=======================================================
// class CCopyPackageMapResponse Implementation
//=======================================================

CCopyPackageMapResponse::CCopyPackageMapResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CCopyPackageMapResponse::CCopyPackageMapResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapResponse");
}

CCopyPackageMapResponse::CCopyPackageMapResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CCopyPackageMapResponse::CCopyPackageMapResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("CopyPackageMapResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CCopyPackageMapResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FilesNotFound\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"File\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CCopyPackageMapResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CCopyPackageMapResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CCopyPackageMapResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FilesNotFound");
	form.appendf("<tr><td><b>FilesNotFound: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CCopyPackageMapResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CCopyPackageMapResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_FilesNotFound.marshall(rpc_resp, "FilesNotFound", "File");
	}
}


void CCopyPackageMapResponse::copy(CCopyPackageMapResponse &from)
{
	m_status.copy(from.m_status);
	m_FilesNotFound.copy(from.m_FilesNotFound);
}


void CCopyPackageMapResponse::copy(IConstCopyPackageMapResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setFilesNotFound(ifrom.getFilesNotFound());
}


void CCopyPackageMapResponse::getAttributes(IProperties &attributes)
{
}


void CCopyPackageMapResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_FilesNotFound.toStr(ctx, buffer, "FilesNotFound", "File");
	}
}


void CCopyPackageMapResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CCopyPackageMapResponse::serializer(IEspContext* ctx, IConstCopyPackageMapResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<CopyPackageMapResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field FilesNotFound
	{
		StringArray& v = src.getFilesNotFound();
		if (v.length()>0)
			buffer.append("<FilesNotFound>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<File>%s</File>",v.item(i));
		if (v.length()>0)
			buffer.append("</FilesNotFound>");
	}
	if (keepRootTag)
		buffer.append("</CopyPackageMapResponse>");
}

bool CCopyPackageMapResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_FilesNotFound.unmarshall(rpc_request, "FilesNotFound", basepath);
	}
	return hasValue;
}

bool CCopyPackageMapResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_FilesNotFound.unmarshall(ctx, soapval, "FilesNotFound");
	return hasValue;
}

bool CCopyPackageMapResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_FilesNotFound.unmarshall(ctx, params, attachments, "FilesNotFound", basepath);
	return hasValue;
}

IConstBasePackageStatus & CCopyPackageMapResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
StringArray & CCopyPackageMapResponse::getFilesNotFound() { return (StringArray &) m_FilesNotFound; }
IEspBasePackageStatus & CCopyPackageMapResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CCopyPackageMapResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CCopyPackageMapResponse::setFilesNotFound(StringArray &val){ m_FilesNotFound->kill();  CloneArray(m_FilesNotFound.getValue(), val); }
extern "C"  IEspCopyPackageMapResponse *createCopyPackageMapResponse(const char *serv){return ((IEspCopyPackageMapResponse *)new CCopyPackageMapResponse(serv));}
extern "C"  IClientCopyPackageMapResponse *createClientCopyPackageMapResponse(const char *serv){return ((IClientCopyPackageMapResponse *)new CCopyPackageMapResponse(serv));}

//=======================================================
// class CDeletePackageRequest Implementation
//=======================================================

CDeletePackageRequest::CDeletePackageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PackageMaps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeletePackageRequest::CDeletePackageRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PackageMaps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageRequest");
}

CDeletePackageRequest::CDeletePackageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PackageMaps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeletePackageRequest::CDeletePackageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PackageMaps(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeletePackageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMap\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMaps\">\n");
		schema.append("<xsd:complexType><xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PackageMap\" type=\"tns:PackageMapEntry\"/>");
		schema.append("</xsd:sequence></xsd:complexType>");
		schema.append("</xsd:element>");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CPackageMapEntry::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDeletePackageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeletePackageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("PackageMapEntry"))
	{
		added.setValue("PackageMapEntry",1);
		CPackageMapEntry::getMapInfo(info,added);
	}
}

StringBuffer &CDeletePackageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMap");
	form.appendf("  <tr><td><b>PackageMap: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMaps");
	form.appendf("<tr><td><b>PackageMaps: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeletePackageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeletePackageRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_PackageMap.marshall(rpc_resp, "PackageMap", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
	m_PackageMaps.marshall(rpc_resp, "PackageMaps", "PackageMap");
}


void CDeletePackageRequest::copy(CDeletePackageRequest &from)
{
	m_Target.copy(from.m_Target);
	m_PackageMap.copy(from.m_PackageMap);
	m_Process.copy(from.m_Process);
	m_GlobalScope.copy(from.m_GlobalScope);
	m_PackageMaps.copy(from.m_PackageMaps);
}


void CDeletePackageRequest::copy(IConstDeletePackageRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setPackageMap(ifrom.getPackageMap());
	setProcess(ifrom.getProcess());
	setGlobalScope(ifrom.getGlobalScope());
	setPackageMaps(ifrom.getPackageMaps());
}


void CDeletePackageRequest::getAttributes(IProperties &attributes)
{
}


void CDeletePackageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_PackageMap.toStr(ctx, buffer, "PackageMap", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
	m_PackageMaps.toStr(ctx, buffer, "PackageMaps", "PackageMap");
}


void CDeletePackageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeletePackageRequest::serializer(IEspContext* ctx, IConstDeletePackageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeletePackageRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field PackageMap
	{
		const char* s = src.getPackageMap();
		if (s && *s)
		{
			buffer.append("<PackageMap>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMap>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	// field PackageMaps
	{
		IArrayOf<IConstPackageMapEntry>& v = src.getPackageMaps();
		int size = v.length();
		if (size>0)
			buffer.append("<PackageMaps>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<PackageMap>");
			CPackageMapEntry::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</PackageMap>");
		}
		if (size>0)
			buffer.append("</PackageMaps>");
	}
	if (keepRootTag)
		buffer.append("</DeletePackageRequest>");
}

bool CDeletePackageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(rpc_request, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	hasValue |= m_PackageMaps.unmarshall(rpc_request, "PackageMaps", basepath);
	return hasValue;
}

bool CDeletePackageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_PackageMap.unmarshall(ctx, soapval, "PackageMap");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	hasValue |= m_PackageMaps.unmarshall(ctx, soapval, "PackageMaps");
	return hasValue;
}

bool CDeletePackageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(ctx, params, attachments, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	hasValue |= m_PackageMaps.unmarshall(ctx, params, attachments, "PackageMaps", basepath);
	return hasValue;
}

const char * CDeletePackageRequest::getTarget() { return m_Target.query();}
const char * CDeletePackageRequest::getPackageMap() { return m_PackageMap.query();}
const char * CDeletePackageRequest::getProcess() { return m_Process.query();}
bool CDeletePackageRequest::getGlobalScope() { return m_GlobalScope;}
IArrayOf<IConstPackageMapEntry> & CDeletePackageRequest::getPackageMaps() { return (IArrayOf<IConstPackageMapEntry> &) m_PackageMaps; }
void CDeletePackageRequest::setTarget(const char * val){ m_Target.set(val); }
void CDeletePackageRequest::setPackageMap(const char * val){ m_PackageMap.set(val); }
void CDeletePackageRequest::setProcess(const char * val){ m_Process.set(val); }
void CDeletePackageRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
void CDeletePackageRequest::setPackageMaps(IArrayOf<IEspPackageMapEntry> &val)
{
	m_PackageMaps->kill();
	IArrayOf<IConstPackageMapEntry> &target = m_PackageMaps.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPackageMapEntry &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CDeletePackageRequest::setPackageMaps(IArrayOf<IConstPackageMapEntry> &val)
{
	m_PackageMaps->kill();
	IArrayOf<IConstPackageMapEntry> &target = m_PackageMaps.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPackageMapEntry &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspDeletePackageRequest *createDeletePackageRequest(const char *serv){return ((IEspDeletePackageRequest *)new CDeletePackageRequest(serv));}
extern "C"  IClientDeletePackageRequest *createClientDeletePackageRequest(const char *serv){return ((IClientDeletePackageRequest *)new CDeletePackageRequest(serv));}

//=======================================================
// class CDeletePackageResponse Implementation
//=======================================================

CDeletePackageResponse::CDeletePackageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeletePackageResponse::CDeletePackageResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageResponse");
}

CDeletePackageResponse::CDeletePackageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeletePackageResponse::CDeletePackageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeletePackageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeletePackageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDeletePackageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeletePackageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CDeletePackageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeletePackageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeletePackageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
	}
}


void CDeletePackageResponse::copy(CDeletePackageResponse &from)
{
	m_status.copy(from.m_status);
}


void CDeletePackageResponse::copy(IConstDeletePackageResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CDeletePackageResponse::getAttributes(IProperties &attributes)
{
}


void CDeletePackageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
	}
}


void CDeletePackageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeletePackageResponse::serializer(IEspContext* ctx, IConstDeletePackageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeletePackageResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</DeletePackageResponse>");
}

bool CDeletePackageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
	}
	return hasValue;
}

bool CDeletePackageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	return hasValue;
}

bool CDeletePackageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	return hasValue;
}

IConstBasePackageStatus & CDeletePackageResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
IEspBasePackageStatus & CDeletePackageResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CDeletePackageResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
extern "C"  IEspDeletePackageResponse *createDeletePackageResponse(const char *serv){return ((IEspDeletePackageResponse *)new CDeletePackageResponse(serv));}
extern "C"  IClientDeletePackageResponse *createClientDeletePackageResponse(const char *serv){return ((IClientDeletePackageResponse *)new CDeletePackageResponse(serv));}

//=======================================================
// class CActivatePackageRequest Implementation
//=======================================================

CActivatePackageRequest::CActivatePackageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CActivatePackageRequest::CActivatePackageRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageRequest");
}

CActivatePackageRequest::CActivatePackageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CActivatePackageRequest::CActivatePackageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CActivatePackageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMap\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CActivatePackageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CActivatePackageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CActivatePackageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMap");
	form.appendf("  <tr><td><b>PackageMap: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CActivatePackageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CActivatePackageRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_PackageMap.marshall(rpc_resp, "PackageMap", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
}


void CActivatePackageRequest::copy(CActivatePackageRequest &from)
{
	m_Target.copy(from.m_Target);
	m_PackageMap.copy(from.m_PackageMap);
	m_Process.copy(from.m_Process);
	m_GlobalScope.copy(from.m_GlobalScope);
}


void CActivatePackageRequest::copy(IConstActivatePackageRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setPackageMap(ifrom.getPackageMap());
	setProcess(ifrom.getProcess());
	setGlobalScope(ifrom.getGlobalScope());
}


void CActivatePackageRequest::getAttributes(IProperties &attributes)
{
}


void CActivatePackageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_PackageMap.toStr(ctx, buffer, "PackageMap", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
}


void CActivatePackageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CActivatePackageRequest::serializer(IEspContext* ctx, IConstActivatePackageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ActivatePackageRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field PackageMap
	{
		const char* s = src.getPackageMap();
		if (s && *s)
		{
			buffer.append("<PackageMap>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMap>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	if (keepRootTag)
		buffer.append("</ActivatePackageRequest>");
}

bool CActivatePackageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(rpc_request, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	return hasValue;
}

bool CActivatePackageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_PackageMap.unmarshall(ctx, soapval, "PackageMap");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	return hasValue;
}

bool CActivatePackageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(ctx, params, attachments, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	return hasValue;
}

const char * CActivatePackageRequest::getTarget() { return m_Target.query();}
const char * CActivatePackageRequest::getPackageMap() { return m_PackageMap.query();}
const char * CActivatePackageRequest::getProcess() { return m_Process.query();}
bool CActivatePackageRequest::getGlobalScope() { return m_GlobalScope;}
void CActivatePackageRequest::setTarget(const char * val){ m_Target.set(val); }
void CActivatePackageRequest::setPackageMap(const char * val){ m_PackageMap.set(val); }
void CActivatePackageRequest::setProcess(const char * val){ m_Process.set(val); }
void CActivatePackageRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
extern "C"  IEspActivatePackageRequest *createActivatePackageRequest(const char *serv){return ((IEspActivatePackageRequest *)new CActivatePackageRequest(serv));}
extern "C"  IClientActivatePackageRequest *createClientActivatePackageRequest(const char *serv){return ((IClientActivatePackageRequest *)new CActivatePackageRequest(serv));}

//=======================================================
// class CActivatePackageResponse Implementation
//=======================================================

CActivatePackageResponse::CActivatePackageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CActivatePackageResponse::CActivatePackageResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageResponse");
}

CActivatePackageResponse::CActivatePackageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CActivatePackageResponse::CActivatePackageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ActivatePackageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CActivatePackageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CActivatePackageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CActivatePackageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CActivatePackageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CActivatePackageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CActivatePackageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
	}
}


void CActivatePackageResponse::copy(CActivatePackageResponse &from)
{
	m_status.copy(from.m_status);
}


void CActivatePackageResponse::copy(IConstActivatePackageResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CActivatePackageResponse::getAttributes(IProperties &attributes)
{
}


void CActivatePackageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
	}
}


void CActivatePackageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CActivatePackageResponse::serializer(IEspContext* ctx, IConstActivatePackageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ActivatePackageResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</ActivatePackageResponse>");
}

bool CActivatePackageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
	}
	return hasValue;
}

bool CActivatePackageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	return hasValue;
}

bool CActivatePackageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	return hasValue;
}

IConstBasePackageStatus & CActivatePackageResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
IEspBasePackageStatus & CActivatePackageResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CActivatePackageResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
extern "C"  IEspActivatePackageResponse *createActivatePackageResponse(const char *serv){return ((IEspActivatePackageResponse *)new CActivatePackageResponse(serv));}
extern "C"  IClientActivatePackageResponse *createClientActivatePackageResponse(const char *serv){return ((IClientActivatePackageResponse *)new CActivatePackageResponse(serv));}

//=======================================================
// class CDeActivatePackageRequest Implementation
//=======================================================

CDeActivatePackageRequest::CDeActivatePackageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeActivatePackageRequest::CDeActivatePackageRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageRequest");
}

CDeActivatePackageRequest::CDeActivatePackageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeActivatePackageRequest::CDeActivatePackageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_Process(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeActivatePackageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMap\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CDeActivatePackageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeActivatePackageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CDeActivatePackageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMap");
	form.appendf("  <tr><td><b>PackageMap: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeActivatePackageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeActivatePackageRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_PackageMap.marshall(rpc_resp, "PackageMap", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
}


void CDeActivatePackageRequest::copy(CDeActivatePackageRequest &from)
{
	m_Target.copy(from.m_Target);
	m_PackageMap.copy(from.m_PackageMap);
	m_Process.copy(from.m_Process);
	m_GlobalScope.copy(from.m_GlobalScope);
}


void CDeActivatePackageRequest::copy(IConstDeActivatePackageRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setPackageMap(ifrom.getPackageMap());
	setProcess(ifrom.getProcess());
	setGlobalScope(ifrom.getGlobalScope());
}


void CDeActivatePackageRequest::getAttributes(IProperties &attributes)
{
}


void CDeActivatePackageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_PackageMap.toStr(ctx, buffer, "PackageMap", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
}


void CDeActivatePackageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeActivatePackageRequest::serializer(IEspContext* ctx, IConstDeActivatePackageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeActivatePackageRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field PackageMap
	{
		const char* s = src.getPackageMap();
		if (s && *s)
		{
			buffer.append("<PackageMap>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMap>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	if (keepRootTag)
		buffer.append("</DeActivatePackageRequest>");
}

bool CDeActivatePackageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(rpc_request, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	return hasValue;
}

bool CDeActivatePackageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_PackageMap.unmarshall(ctx, soapval, "PackageMap");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	return hasValue;
}

bool CDeActivatePackageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(ctx, params, attachments, "PackageMap", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	return hasValue;
}

const char * CDeActivatePackageRequest::getTarget() { return m_Target.query();}
const char * CDeActivatePackageRequest::getPackageMap() { return m_PackageMap.query();}
const char * CDeActivatePackageRequest::getProcess() { return m_Process.query();}
bool CDeActivatePackageRequest::getGlobalScope() { return m_GlobalScope;}
void CDeActivatePackageRequest::setTarget(const char * val){ m_Target.set(val); }
void CDeActivatePackageRequest::setPackageMap(const char * val){ m_PackageMap.set(val); }
void CDeActivatePackageRequest::setProcess(const char * val){ m_Process.set(val); }
void CDeActivatePackageRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
extern "C"  IEspDeActivatePackageRequest *createDeActivatePackageRequest(const char *serv){return ((IEspDeActivatePackageRequest *)new CDeActivatePackageRequest(serv));}
extern "C"  IClientDeActivatePackageRequest *createClientDeActivatePackageRequest(const char *serv){return ((IClientDeActivatePackageRequest *)new CDeActivatePackageRequest(serv));}

//=======================================================
// class CDeActivatePackageResponse Implementation
//=======================================================

CDeActivatePackageResponse::CDeActivatePackageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CDeActivatePackageResponse::CDeActivatePackageResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageResponse");
}

CDeActivatePackageResponse::CDeActivatePackageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CDeActivatePackageResponse::CDeActivatePackageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("DeActivatePackageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CDeActivatePackageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CDeActivatePackageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CDeActivatePackageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CDeActivatePackageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CDeActivatePackageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CDeActivatePackageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
	}
}


void CDeActivatePackageResponse::copy(CDeActivatePackageResponse &from)
{
	m_status.copy(from.m_status);
}


void CDeActivatePackageResponse::copy(IConstDeActivatePackageResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CDeActivatePackageResponse::getAttributes(IProperties &attributes)
{
}


void CDeActivatePackageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
	}
}


void CDeActivatePackageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CDeActivatePackageResponse::serializer(IEspContext* ctx, IConstDeActivatePackageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<DeActivatePackageResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</DeActivatePackageResponse>");
}

bool CDeActivatePackageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
	}
	return hasValue;
}

bool CDeActivatePackageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	return hasValue;
}

bool CDeActivatePackageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	return hasValue;
}

IConstBasePackageStatus & CDeActivatePackageResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
IEspBasePackageStatus & CDeActivatePackageResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CDeActivatePackageResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
extern "C"  IEspDeActivatePackageResponse *createDeActivatePackageResponse(const char *serv){return ((IEspDeActivatePackageResponse *)new CDeActivatePackageResponse(serv));}
extern "C"  IClientDeActivatePackageResponse *createClientDeActivatePackageResponse(const char *serv){return ((IClientDeActivatePackageResponse *)new CDeActivatePackageResponse(serv));}

//=======================================================
// class CGetPackageRequest Implementation
//=======================================================

CGetPackageRequest::CGetPackageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPackageRequest::CGetPackageRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageRequest");
}

CGetPackageRequest::CGetPackageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPackageRequest::CGetPackageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPackageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetPackageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPackageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetPackageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPackageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPackageRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
}


void CGetPackageRequest::copy(CGetPackageRequest &from)
{
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
}


void CGetPackageRequest::copy(IConstGetPackageRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
}


void CGetPackageRequest::getAttributes(IProperties &attributes)
{
}


void CGetPackageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
}


void CGetPackageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPackageRequest::serializer(IEspContext* ctx, IConstGetPackageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPackageRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetPackageRequest>");
}

bool CGetPackageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	return hasValue;
}

bool CGetPackageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	return hasValue;
}

bool CGetPackageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	return hasValue;
}

const char * CGetPackageRequest::getTarget() { return m_Target.query();}
const char * CGetPackageRequest::getProcess() { return m_Process.query();}
void CGetPackageRequest::setTarget(const char * val){ m_Target.set(val); }
void CGetPackageRequest::setProcess(const char * val){ m_Process.set(val); }
extern "C"  IEspGetPackageRequest *createGetPackageRequest(const char *serv){return ((IEspGetPackageRequest *)new CGetPackageRequest(serv));}
extern "C"  IClientGetPackageRequest *createClientGetPackageRequest(const char *serv){return ((IClientGetPackageRequest *)new CGetPackageRequest(serv));}

//=======================================================
// class CGetPackageResponse Implementation
//=======================================================

CGetPackageResponse::CGetPackageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPackageResponse::CGetPackageResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageResponse");
}

CGetPackageResponse::CGetPackageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPackageResponse::CGetPackageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPackageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Info\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetPackageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPackageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CGetPackageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Info");
	form.appendf("  <tr><td><b>Info: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPackageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPackageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_Info.marshall(rpc_resp, "Info", "", "", "");
	}
}


void CGetPackageResponse::copy(CGetPackageResponse &from)
{
	m_status.copy(from.m_status);
	m_Info.copy(from.m_Info);
}


void CGetPackageResponse::copy(IConstGetPackageResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setInfo(ifrom.getInfo());
}


void CGetPackageResponse::getAttributes(IProperties &attributes)
{
}


void CGetPackageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_Info.toStr(ctx, buffer, "Info", "", true, "", "");
	}
}


void CGetPackageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPackageResponse::serializer(IEspContext* ctx, IConstGetPackageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPackageResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field Info
	{
		const char* s = src.getInfo();
		if (s && *s)
		{
			buffer.append("<Info>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Info>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetPackageResponse>");
}

bool CGetPackageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_Info.unmarshall(rpc_request, "Info", basepath);
	}
	return hasValue;
}

bool CGetPackageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_Info.unmarshall(ctx, soapval, "Info");
	return hasValue;
}

bool CGetPackageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_Info.unmarshall(ctx, params, attachments, "Info", basepath);
	return hasValue;
}

IConstBasePackageStatus & CGetPackageResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
const char * CGetPackageResponse::getInfo() { return m_Info.query();}
IEspBasePackageStatus & CGetPackageResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CGetPackageResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CGetPackageResponse::setInfo(const char * val){ m_Info.set(val); }
extern "C"  IEspGetPackageResponse *createGetPackageResponse(const char *serv){return ((IEspGetPackageResponse *)new CGetPackageResponse(serv));}
extern "C"  IClientGetPackageResponse *createClientGetPackageResponse(const char *serv){return ((IClientGetPackageResponse *)new CGetPackageResponse(serv));}

//=======================================================
// class CGetPackageMapByIdRequest Implementation
//=======================================================

CGetPackageMapByIdRequest::CGetPackageMapByIdRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_PackageMapId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPackageMapByIdRequest::CGetPackageMapByIdRequest(const char *serviceName, const char *bc)
	: m_PackageMapId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdRequest");
}

CGetPackageMapByIdRequest::CGetPackageMapByIdRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_PackageMapId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPackageMapByIdRequest::CGetPackageMapByIdRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_PackageMapId(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPackageMapByIdRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMapId\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetPackageMapByIdRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPackageMapByIdRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetPackageMapByIdRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMapId");
	form.appendf("  <tr><td><b>PackageMapId: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPackageMapByIdRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPackageMapByIdRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_PackageMapId.marshall(rpc_resp, "PackageMapId", "", "", "");
}


void CGetPackageMapByIdRequest::copy(CGetPackageMapByIdRequest &from)
{
	m_PackageMapId.copy(from.m_PackageMapId);
}


void CGetPackageMapByIdRequest::copy(IConstGetPackageMapByIdRequest &ifrom)
{
	setPackageMapId(ifrom.getPackageMapId());
}


void CGetPackageMapByIdRequest::getAttributes(IProperties &attributes)
{
}


void CGetPackageMapByIdRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_PackageMapId.toStr(ctx, buffer, "PackageMapId", "", true, "", "");
}


void CGetPackageMapByIdRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPackageMapByIdRequest::serializer(IEspContext* ctx, IConstGetPackageMapByIdRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPackageMapByIdRequest>");
	// field PackageMapId
	{
		const char* s = src.getPackageMapId();
		if (s && *s)
		{
			buffer.append("<PackageMapId>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMapId>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetPackageMapByIdRequest>");
}

bool CGetPackageMapByIdRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_PackageMapId.unmarshall(rpc_request, "PackageMapId", basepath);
	return hasValue;
}

bool CGetPackageMapByIdRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_PackageMapId.unmarshall(ctx, soapval, "PackageMapId");
	return hasValue;
}

bool CGetPackageMapByIdRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_PackageMapId.unmarshall(ctx, params, attachments, "PackageMapId", basepath);
	return hasValue;
}

const char * CGetPackageMapByIdRequest::getPackageMapId() { return m_PackageMapId.query();}
void CGetPackageMapByIdRequest::setPackageMapId(const char * val){ m_PackageMapId.set(val); }
extern "C"  IEspGetPackageMapByIdRequest *createGetPackageMapByIdRequest(const char *serv){return ((IEspGetPackageMapByIdRequest *)new CGetPackageMapByIdRequest(serv));}
extern "C"  IClientGetPackageMapByIdRequest *createClientGetPackageMapByIdRequest(const char *serv){return ((IClientGetPackageMapByIdRequest *)new CGetPackageMapByIdRequest(serv));}

//=======================================================
// class CGetPackageMapByIdResponse Implementation
//=======================================================

CGetPackageMapByIdResponse::CGetPackageMapByIdResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPackageMapByIdResponse::CGetPackageMapByIdResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdResponse");
}

CGetPackageMapByIdResponse::CGetPackageMapByIdResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPackageMapByIdResponse::CGetPackageMapByIdResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_Info(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapByIdResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPackageMapByIdResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Info\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetPackageMapByIdResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPackageMapByIdResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CGetPackageMapByIdResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Info");
	form.appendf("  <tr><td><b>Info: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPackageMapByIdResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPackageMapByIdResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_Info.marshall(rpc_resp, "Info", "", "", "");
	}
}


void CGetPackageMapByIdResponse::copy(CGetPackageMapByIdResponse &from)
{
	m_status.copy(from.m_status);
	m_Info.copy(from.m_Info);
}


void CGetPackageMapByIdResponse::copy(IConstGetPackageMapByIdResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setInfo(ifrom.getInfo());
}


void CGetPackageMapByIdResponse::getAttributes(IProperties &attributes)
{
}


void CGetPackageMapByIdResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_Info.toStr(ctx, buffer, "Info", "", true, "", "");
	}
}


void CGetPackageMapByIdResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPackageMapByIdResponse::serializer(IEspContext* ctx, IConstGetPackageMapByIdResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPackageMapByIdResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field Info
	{
		const char* s = src.getInfo();
		if (s && *s)
		{
			buffer.append("<Info>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Info>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetPackageMapByIdResponse>");
}

bool CGetPackageMapByIdResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_Info.unmarshall(rpc_request, "Info", basepath);
	}
	return hasValue;
}

bool CGetPackageMapByIdResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_Info.unmarshall(ctx, soapval, "Info");
	return hasValue;
}

bool CGetPackageMapByIdResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_Info.unmarshall(ctx, params, attachments, "Info", basepath);
	return hasValue;
}

IConstBasePackageStatus & CGetPackageMapByIdResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
const char * CGetPackageMapByIdResponse::getInfo() { return m_Info.query();}
IEspBasePackageStatus & CGetPackageMapByIdResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CGetPackageMapByIdResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CGetPackageMapByIdResponse::setInfo(const char * val){ m_Info.set(val); }
extern "C"  IEspGetPackageMapByIdResponse *createGetPackageMapByIdResponse(const char *serv){return ((IEspGetPackageMapByIdResponse *)new CGetPackageMapByIdResponse(serv));}
extern "C"  IClientGetPackageMapByIdResponse *createClientGetPackageMapByIdResponse(const char *serv){return ((IClientGetPackageMapByIdResponse *)new CGetPackageMapByIdResponse(serv));}

//=======================================================
// class CListPackageRequest Implementation
//=======================================================

CListPackageRequest::CListPackageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListPackageRequest::CListPackageRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageRequest");
}

CListPackageRequest::CListPackageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CListPackageRequest::CListPackageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_Process(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListPackageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CListPackageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListPackageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CListPackageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListPackageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListPackageRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
}


void CListPackageRequest::copy(CListPackageRequest &from)
{
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
}


void CListPackageRequest::copy(IConstListPackageRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
}


void CListPackageRequest::getAttributes(IProperties &attributes)
{
}


void CListPackageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
}


void CListPackageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListPackageRequest::serializer(IEspContext* ctx, IConstListPackageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListPackageRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	if (keepRootTag)
		buffer.append("</ListPackageRequest>");
}

bool CListPackageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	return hasValue;
}

bool CListPackageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	return hasValue;
}

bool CListPackageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	return hasValue;
}

const char * CListPackageRequest::getTarget() { return m_Target.query();}
const char * CListPackageRequest::getProcess() { return m_Process.query();}
void CListPackageRequest::setTarget(const char * val){ m_Target.set(val); }
void CListPackageRequest::setProcess(const char * val){ m_Process.set(val); }
extern "C"  IEspListPackageRequest *createListPackageRequest(const char *serv){return ((IEspListPackageRequest *)new CListPackageRequest(serv));}
extern "C"  IClientListPackageRequest *createClientListPackageRequest(const char *serv){return ((IClientListPackageRequest *)new CListPackageRequest(serv));}

//=======================================================
// class CPackageListData Implementation
//=======================================================

CPackageListData::CPackageListData(const char *serviceName, IRpcMessageBinding *init)
	: m_Id(nilIgnore),m_Queries(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PackageListData");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPackageListData::CPackageListData(const char *serviceName, const char *bc)
	: m_Id(nilIgnore),m_Queries(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PackageListData");
}

StringBuffer &CPackageListData::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Id\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Queries\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CPackageListData::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPackageListData::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CPackageListData::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Id");
	form.appendf("  <tr><td><b>Id: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Queries");
	form.appendf("  <tr><td><b>Queries: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPackageListData::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPackageListData::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Id.marshall(rpc_resp, "Id", "", "", "");
	m_Queries.marshall(rpc_resp, "Queries", "", "", "");
}


void CPackageListData::copy(CPackageListData &from)
{
	m_Id.copy(from.m_Id);
	m_Queries.copy(from.m_Queries);
}


void CPackageListData::copy(IConstPackageListData &ifrom)
{
	setId(ifrom.getId());
	setQueries(ifrom.getQueries());
}


void CPackageListData::getAttributes(IProperties &attributes)
{
}


void CPackageListData::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Id.toStr(ctx, buffer, "Id", "", true, "", "");
	m_Queries.toStr(ctx, buffer, "Queries", "", true, "", "");
}


void CPackageListData::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPackageListData::serializer(IEspContext* ctx, IConstPackageListData &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PackageListData>");
	// field Id
	{
		const char* s = src.getId();
		if (s && *s)
		{
			buffer.append("<Id>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Id>");
		}
	}
	// field Queries
	{
		const char* s = src.getQueries();
		if (s && *s)
		{
			buffer.append("<Queries>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Queries>");
		}
	}
	if (keepRootTag)
		buffer.append("</PackageListData>");
}

bool CPackageListData::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(rpc_request, "Id", basepath);
	hasValue |= m_Queries.unmarshall(rpc_request, "Queries", basepath);
	return hasValue;
}

bool CPackageListData::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, soapval, "Id");
	hasValue |= m_Queries.unmarshall(ctx, soapval, "Queries");
	return hasValue;
}

bool CPackageListData::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, params, attachments, "Id", basepath);
	hasValue |= m_Queries.unmarshall(ctx, params, attachments, "Queries", basepath);
	return hasValue;
}

const char * CPackageListData::getId() { return m_Id.query();}
const char * CPackageListData::getQueries() { return m_Queries.query();}
void CPackageListData::setId(const char * val){ m_Id.set(val); }
void CPackageListData::setQueries(const char * val){ m_Queries.set(val); }
extern "C"  IEspPackageListData *createPackageListData(const char *serv, const char *msgname){return ((IEspPackageListData *)new CPackageListData(serv /*, msgname*/));}
extern "C"  IClientPackageListData *createClientPackageListData(const char *serv, const char *msgname){return ((IClientPackageListData *)new CPackageListData(serv /*, msgname*/));}

//=======================================================
// class CPackageListMapData Implementation
//=======================================================

CPackageListMapData::CPackageListMapData(const char *serviceName, IRpcMessageBinding *init)
	: m_Id(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_PkgListData(nilIgnore),m_Active(nilIgnore),m_Description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PackageListMapData");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CPackageListMapData::CPackageListMapData(const char *serviceName, const char *bc)
	: m_Id(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_PkgListData(nilIgnore),m_Active(nilIgnore),m_Description(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("PackageListMapData");
}

StringBuffer &CPackageListMapData::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Id\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		if (!context.suppressed("PackageListMapData","Process")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PkgListData\" type=\"tns:ArrayOfPackageListData\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Active\" type=\"xsd:boolean\"/>\n");
		if (!context.suppressed("PackageListMapData","Description")) {
			schema.append("<xsd:element minOccurs=\"0\" name=\"Description\" type=\"xsd:string\"/>\n");
		}
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CPackageListData::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("PackageListData") && added.getValue("ArrayOfPackageListData")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPackageListData\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PackageListData\" type=\"tns:PackageListData\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPackageListData",1);
	}
	return schema;
}

void CPackageListMapData::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CPackageListMapData::getMapInfo(IMapInfo& info, BoolHash& added)
{
	info.addMinVersion("PackageListMapData","Process",1.01);
	info.addMinVersion("PackageListMapData","Description",1.01);
	if (!added.getValue("PackageListData"))
	{
		added.setValue("PackageListData",1);
		CPackageListData::getMapInfo(info,added);
	}
}

StringBuffer &CPackageListMapData::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Id");
	form.appendf("  <tr><td><b>Id: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (!context.suppressed("PackageListMapData","Process")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Process");
		form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PkgListData");
	form.appendf("<tr><td><b>PkgListData: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Active");
	
	form.appendf("  <tr><td><b>Active? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (!context.suppressed("PackageListMapData","Description")) {
		extfix.clear();
		if (prefix && *prefix)
			extfix.append(prefix).append(".");
		extfix.append("Description");
		form.appendf("  <tr><td><b>Description: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
		form.append("</td></tr>\n");
	}
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CPackageListMapData::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CPackageListMapData::serialize(IRpcMessage& rpc_resp)
{
	IEspContext* ctx = rpc_resp.queryContext();
	double clientVer= ctx ? ctx->getClientVersion() : -1; /* no context gets everything */
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Id.marshall(rpc_resp, "Id", "", "", "");
	m_Target.marshall(rpc_resp, "Target", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_PkgListData.marshall(rpc_resp, "PkgListData", "PackageListData");
	m_Active.marshall(rpc_resp, "Active", "", "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Description.marshall(rpc_resp, "Description", "", "", "");
}


void CPackageListMapData::copy(CPackageListMapData &from)
{
	m_Id.copy(from.m_Id);
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
	m_PkgListData.copy(from.m_PkgListData);
	m_Active.copy(from.m_Active);
	m_Description.copy(from.m_Description);
}


void CPackageListMapData::copy(IConstPackageListMapData &ifrom)
{
	setId(ifrom.getId());
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
	setPkgListData(ifrom.getPkgListData());
	setActive(ifrom.getActive());
	setDescription(ifrom.getDescription());
}


void CPackageListMapData::getAttributes(IProperties &attributes)
{
}


void CPackageListMapData::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	m_Id.toStr(ctx, buffer, "Id", "", true, "", "");
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_PkgListData.toStr(ctx, buffer, "PkgListData", "PackageListData");
	m_Active.toStr(ctx, buffer, "Active", "", true, "", "");
	if ((clientVer==-1.0 || clientVer>=1.01))
		m_Description.toStr(ctx, buffer, "Description", "", true, "", "");
}


void CPackageListMapData::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CPackageListMapData::serializer(IEspContext* ctx, IConstPackageListMapData &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<PackageListMapData>");
	double clientVer = ctx ? ctx->getClientVersion() : -1;
	// field Id
	{
		const char* s = src.getId();
		if (s && *s)
		{
			buffer.append("<Id>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Id>");
		}
	}
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field PkgListData
	{
		IArrayOf<IConstPackageListData>& v = src.getPkgListData();
		int size = v.length();
		if (size>0)
			buffer.append("<PkgListData>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPackageListData::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</PkgListData>");
	}
	// field Active
	{
		bool b = src.getActive();
		if (b)
			buffer.appendf("<Active>1</Active>");
	}
	// field Description
	if ((clientVer==-1.0 || clientVer>=1.01))
	{
		const char* s = src.getDescription();
		if (s && *s)
		{
			buffer.append("<Description>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Description>");
		}
	}
	if (keepRootTag)
		buffer.append("</PackageListMapData>");
}

bool CPackageListMapData::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(rpc_request, "Id", basepath);
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_PkgListData.unmarshall(rpc_request, "PkgListData", basepath);
	hasValue |= m_Active.unmarshall(rpc_request, "Active", basepath);
	hasValue |= m_Description.unmarshall(rpc_request, "Description", basepath);
	return hasValue;
}

bool CPackageListMapData::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, soapval, "Id");
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_PkgListData.unmarshall(ctx, soapval, "PkgListData");
	hasValue |= m_Active.unmarshall(ctx, soapval, "Active");
	hasValue |= m_Description.unmarshall(ctx, soapval, "Description");
	return hasValue;
}

bool CPackageListMapData::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Id.unmarshall(ctx, params, attachments, "Id", basepath);
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_PkgListData.unmarshall(ctx, params, attachments, "PkgListData", basepath);
	hasValue |= m_Active.unmarshall(ctx, params, attachments, "Active", basepath);
	hasValue |= m_Description.unmarshall(ctx, params, attachments, "Description", basepath);
	return hasValue;
}

const char * CPackageListMapData::getId() { return m_Id.query();}
const char * CPackageListMapData::getTarget() { return m_Target.query();}
const char * CPackageListMapData::getProcess() { return m_Process.query();}
IArrayOf<IConstPackageListData> & CPackageListMapData::getPkgListData() { return (IArrayOf<IConstPackageListData> &) m_PkgListData; }
bool CPackageListMapData::getActive() { return m_Active;}
const char * CPackageListMapData::getDescription() { return m_Description.query();}
void CPackageListMapData::setId(const char * val){ m_Id.set(val); }
void CPackageListMapData::setTarget(const char * val){ m_Target.set(val); }
void CPackageListMapData::setProcess(const char * val){ m_Process.set(val); }
void CPackageListMapData::setPkgListData(IArrayOf<IEspPackageListData> &val)
{
	m_PkgListData->kill();
	IArrayOf<IConstPackageListData> &target = m_PkgListData.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPackageListData &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CPackageListMapData::setPkgListData(IArrayOf<IConstPackageListData> &val)
{
	m_PkgListData->kill();
	IArrayOf<IConstPackageListData> &target = m_PkgListData.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPackageListData &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CPackageListMapData::setActive(bool val){ m_Active=val; }
void CPackageListMapData::setDescription(const char * val){ m_Description.set(val); }
extern "C"  IEspPackageListMapData *createPackageListMapData(const char *serv, const char *msgname){return ((IEspPackageListMapData *)new CPackageListMapData(serv /*, msgname*/));}
extern "C"  IClientPackageListMapData *createClientPackageListMapData(const char *serv, const char *msgname){return ((IClientPackageListMapData *)new CPackageListMapData(serv /*, msgname*/));}

//=======================================================
// class CListPackageResponse Implementation
//=======================================================

CListPackageResponse::CListPackageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_PkgListMapData(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListPackageResponse::CListPackageResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_PkgListMapData(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageResponse");
}

CListPackageResponse::CListPackageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_PkgListMapData(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CListPackageResponse::CListPackageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_PkgListMapData(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListPackageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PkgListMapData\" type=\"tns:ArrayOfPackageListMapData\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
		CPackageListMapData::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("PackageListMapData") && added.getValue("ArrayOfPackageListMapData")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPackageListMapData\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PackageListMapData\" type=\"tns:PackageListMapData\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPackageListMapData",1);
	}
	return schema;
}

void CListPackageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListPackageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
	if (!added.getValue("PackageListMapData"))
	{
		added.setValue("PackageListMapData",1);
		CPackageListMapData::getMapInfo(info,added);
	}
}

StringBuffer &CListPackageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PkgListMapData");
	form.appendf("<tr><td><b>PkgListMapData: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListPackageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListPackageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_PkgListMapData.marshall(rpc_resp, "PkgListMapData", "PackageListMapData");
	}
}


void CListPackageResponse::copy(CListPackageResponse &from)
{
	m_status.copy(from.m_status);
	m_PkgListMapData.copy(from.m_PkgListMapData);
}


void CListPackageResponse::copy(IConstListPackageResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setPkgListMapData(ifrom.getPkgListMapData());
}


void CListPackageResponse::getAttributes(IProperties &attributes)
{
}


void CListPackageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_PkgListMapData.toStr(ctx, buffer, "PkgListMapData", "PackageListMapData");
	}
}


void CListPackageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListPackageResponse::serializer(IEspContext* ctx, IConstListPackageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListPackageResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field PkgListMapData
	{
		IArrayOf<IConstPackageListMapData>& v = src.getPkgListMapData();
		int size = v.length();
		if (size>0)
			buffer.append("<PkgListMapData>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPackageListMapData::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</PkgListMapData>");
	}
	if (keepRootTag)
		buffer.append("</ListPackageResponse>");
}

bool CListPackageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_PkgListMapData.unmarshall(rpc_request, "PkgListMapData", basepath);
	}
	return hasValue;
}

bool CListPackageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_PkgListMapData.unmarshall(ctx, soapval, "PkgListMapData");
	return hasValue;
}

bool CListPackageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_PkgListMapData.unmarshall(ctx, params, attachments, "PkgListMapData", basepath);
	return hasValue;
}

IConstBasePackageStatus & CListPackageResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
IArrayOf<IConstPackageListMapData> & CListPackageResponse::getPkgListMapData() { return (IArrayOf<IConstPackageListMapData> &) m_PkgListMapData; }
IEspBasePackageStatus & CListPackageResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CListPackageResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CListPackageResponse::setPkgListMapData(IArrayOf<IEspPackageListMapData> &val)
{
	m_PkgListMapData->kill();
	IArrayOf<IConstPackageListMapData> &target = m_PkgListMapData.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPackageListMapData &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CListPackageResponse::setPkgListMapData(IArrayOf<IConstPackageListMapData> &val)
{
	m_PkgListMapData->kill();
	IArrayOf<IConstPackageListMapData> &target = m_PkgListMapData.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPackageListMapData &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspListPackageResponse *createListPackageResponse(const char *serv){return ((IEspListPackageResponse *)new CListPackageResponse(serv));}
extern "C"  IClientListPackageResponse *createClientListPackageResponse(const char *serv){return ((IClientListPackageResponse *)new CListPackageResponse(serv));}

//=======================================================
// class CListPackagesRequest Implementation
//=======================================================

CListPackagesRequest::CListPackagesRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilRemove),m_Process(nilRemove),m_ProcessFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListPackagesRequest::CListPackagesRequest(const char *serviceName, const char *bc)
	: m_Target(nilRemove),m_Process(nilRemove),m_ProcessFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesRequest");
}

CListPackagesRequest::CListPackagesRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilRemove),m_Process(nilRemove),m_ProcessFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CListPackagesRequest::CListPackagesRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilRemove),m_Process(nilRemove),m_ProcessFilter(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListPackagesRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ProcessFilter\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CListPackagesRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListPackagesRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CListPackagesRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ProcessFilter");
	form.appendf("  <tr><td><b>ProcessFilter: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListPackagesRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListPackagesRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_ProcessFilter.marshall(rpc_resp, "ProcessFilter", "", "", "");
}


void CListPackagesRequest::copy(CListPackagesRequest &from)
{
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
	m_ProcessFilter.copy(from.m_ProcessFilter);
}


void CListPackagesRequest::copy(IConstListPackagesRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
	setProcessFilter(ifrom.getProcessFilter());
}


void CListPackagesRequest::getAttributes(IProperties &attributes)
{
}


void CListPackagesRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_ProcessFilter.toStr(ctx, buffer, "ProcessFilter", "", true, "", "");
}


void CListPackagesRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListPackagesRequest::serializer(IEspContext* ctx, IConstListPackagesRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListPackagesRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field ProcessFilter
	{
		const char* s = src.getProcessFilter();
		if (s && *s)
		{
			buffer.append("<ProcessFilter>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ProcessFilter>");
		}
	}
	if (keepRootTag)
		buffer.append("</ListPackagesRequest>");
}

bool CListPackagesRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_ProcessFilter.unmarshall(rpc_request, "ProcessFilter", basepath);
	return hasValue;
}

bool CListPackagesRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_ProcessFilter.unmarshall(ctx, soapval, "ProcessFilter");
	return hasValue;
}

bool CListPackagesRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_ProcessFilter.unmarshall(ctx, params, attachments, "ProcessFilter", basepath);
	return hasValue;
}

const char * CListPackagesRequest::getTarget() { return m_Target.query();}
const char * CListPackagesRequest::getProcess() { return m_Process.query();}
const char * CListPackagesRequest::getProcessFilter() { return m_ProcessFilter.query();}
void CListPackagesRequest::setTarget(const char * val){ m_Target.set(val); }
void CListPackagesRequest::setProcess(const char * val){ m_Process.set(val); }
void CListPackagesRequest::setProcessFilter(const char * val){ m_ProcessFilter.set(val); }
extern "C"  IEspListPackagesRequest *createListPackagesRequest(const char *serv){return ((IEspListPackagesRequest *)new CListPackagesRequest(serv));}
extern "C"  IClientListPackagesRequest *createClientListPackagesRequest(const char *serv){return ((IClientListPackagesRequest *)new CListPackagesRequest(serv));}

//=======================================================
// class CListPackagesResponse Implementation
//=======================================================

CListPackagesResponse::CListPackagesResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilRemove),m_PackageMapList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CListPackagesResponse::CListPackagesResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilRemove),m_PackageMapList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesResponse");
}

CListPackagesResponse::CListPackagesResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilRemove),m_PackageMapList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CListPackagesResponse::CListPackagesResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilRemove),m_PackageMapList(nilRemove)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ListPackagesResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CListPackagesResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMapList\" type=\"tns:ArrayOfPackageListMapData\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
		CPackageListMapData::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("PackageListMapData") && added.getValue("ArrayOfPackageListMapData")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfPackageListMapData\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"PackageListMapData\" type=\"tns:PackageListMapData\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfPackageListMapData",1);
	}
	return schema;
}

void CListPackagesResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CListPackagesResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
	if (!added.getValue("PackageListMapData"))
	{
		added.setValue("PackageListMapData",1);
		CPackageListMapData::getMapInfo(info,added);
	}
}

StringBuffer &CListPackagesResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMapList");
	form.appendf("<tr><td><b>PackageMapList: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CListPackagesResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CListPackagesResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_PackageMapList.marshall(rpc_resp, "PackageMapList", "PackageListMapData");
	}
}


void CListPackagesResponse::copy(CListPackagesResponse &from)
{
	m_status.copy(from.m_status);
	m_PackageMapList.copy(from.m_PackageMapList);
}


void CListPackagesResponse::copy(IConstListPackagesResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setPackageMapList(ifrom.getPackageMapList());
}


void CListPackagesResponse::getAttributes(IProperties &attributes)
{
}


void CListPackagesResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_PackageMapList.toStr(ctx, buffer, "PackageMapList", "PackageListMapData");
	}
}


void CListPackagesResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CListPackagesResponse::serializer(IEspContext* ctx, IConstListPackagesResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ListPackagesResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field PackageMapList
	{
		IArrayOf<IConstPackageListMapData>& v = src.getPackageMapList();
		int size = v.length();
		if (size>0)
			buffer.append("<PackageMapList>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CPackageListMapData::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</PackageMapList>");
	}
	if (keepRootTag)
		buffer.append("</ListPackagesResponse>");
}

bool CListPackagesResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_PackageMapList.unmarshall(rpc_request, "PackageMapList", basepath);
	}
	return hasValue;
}

bool CListPackagesResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_PackageMapList.unmarshall(ctx, soapval, "PackageMapList");
	return hasValue;
}

bool CListPackagesResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_PackageMapList.unmarshall(ctx, params, attachments, "PackageMapList", basepath);
	return hasValue;
}

IConstBasePackageStatus & CListPackagesResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
IArrayOf<IConstPackageListMapData> & CListPackagesResponse::getPackageMapList() { return (IArrayOf<IConstPackageListMapData> &) m_PackageMapList; }
IEspBasePackageStatus & CListPackagesResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CListPackagesResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CListPackagesResponse::setPackageMapList(IArrayOf<IEspPackageListMapData> &val)
{
	m_PackageMapList->kill();
	IArrayOf<IConstPackageListMapData> &target = m_PackageMapList.getValue();
	ForEachItemIn(idx, val)
	{
		IEspPackageListMapData &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CListPackagesResponse::setPackageMapList(IArrayOf<IConstPackageListMapData> &val)
{
	m_PackageMapList->kill();
	IArrayOf<IConstPackageListMapData> &target = m_PackageMapList.getValue();
	ForEachItemIn(idx, val)
	{
		IConstPackageListMapData &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspListPackagesResponse *createListPackagesResponse(const char *serv){return ((IEspListPackagesResponse *)new CListPackagesResponse(serv));}
extern "C"  IClientListPackagesResponse *createClientListPackagesResponse(const char *serv){return ((IClientListPackagesResponse *)new CListPackagesResponse(serv));}

//=======================================================
// class CValidatePackageRequest Implementation
//=======================================================

CValidatePackageRequest::CValidatePackageRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Info(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_Active(nilIgnore),m_PMID(nilIgnore),m_QueryIdToVerify(nilIgnore),m_QueriesToVerify(nilIgnore),m_CheckDFS(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CValidatePackageRequest::CValidatePackageRequest(const char *serviceName, const char *bc)
	: m_Info(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_Active(nilIgnore),m_PMID(nilIgnore),m_QueryIdToVerify(nilIgnore),m_QueriesToVerify(nilIgnore),m_CheckDFS(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageRequest");
}

CValidatePackageRequest::CValidatePackageRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Info(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_Active(nilIgnore),m_PMID(nilIgnore),m_QueryIdToVerify(nilIgnore),m_QueriesToVerify(nilIgnore),m_CheckDFS(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CValidatePackageRequest::CValidatePackageRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Info(nilIgnore),m_Target(nilIgnore),m_Process(nilIgnore),m_Active(nilIgnore),m_PMID(nilIgnore),m_QueryIdToVerify(nilIgnore),m_QueriesToVerify(nilIgnore),m_CheckDFS(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CValidatePackageRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Info\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Active\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PMID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueryIdToVerify\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueriesToVerify\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"CheckDFS\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CValidatePackageRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CValidatePackageRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CValidatePackageRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Info");
	form.appendf("  <tr><td><b>Info: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Active");
	
	form.appendf("  <tr><td><b>Active? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PMID");
	form.appendf("  <tr><td><b>PMID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueryIdToVerify");
	form.appendf("  <tr><td><b>QueryIdToVerify: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueriesToVerify");
	form.appendf("<tr><td><b>QueriesToVerify: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("CheckDFS");
	
	form.appendf("  <tr><td><b>CheckDFS? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CValidatePackageRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CValidatePackageRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Info.marshall(rpc_resp, "Info", "", "", "");
	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_Active.marshall(rpc_resp, "Active", "", "", "");
	m_PMID.marshall(rpc_resp, "PMID", "", "", "");
	m_QueryIdToVerify.marshall(rpc_resp, "QueryIdToVerify", "", "", "");
	m_QueriesToVerify.marshall(rpc_resp, "QueriesToVerify", "Item");
	m_CheckDFS.marshall(rpc_resp, "CheckDFS", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
}


void CValidatePackageRequest::copy(CValidatePackageRequest &from)
{
	m_Info.copy(from.m_Info);
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
	m_Active.copy(from.m_Active);
	m_PMID.copy(from.m_PMID);
	m_QueryIdToVerify.copy(from.m_QueryIdToVerify);
	m_QueriesToVerify.copy(from.m_QueriesToVerify);
	m_CheckDFS.copy(from.m_CheckDFS);
	m_GlobalScope.copy(from.m_GlobalScope);
}


void CValidatePackageRequest::copy(IConstValidatePackageRequest &ifrom)
{
	setInfo(ifrom.getInfo());
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
	setActive(ifrom.getActive());
	setPMID(ifrom.getPMID());
	setQueryIdToVerify(ifrom.getQueryIdToVerify());
	setQueriesToVerify(ifrom.getQueriesToVerify());
	setCheckDFS(ifrom.getCheckDFS());
	setGlobalScope(ifrom.getGlobalScope());
}


void CValidatePackageRequest::getAttributes(IProperties &attributes)
{
}


void CValidatePackageRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Info.toStr(ctx, buffer, "Info", "", true, "", "");
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_Active.toStr(ctx, buffer, "Active", "", true, "", "");
	m_PMID.toStr(ctx, buffer, "PMID", "", true, "", "");
	m_QueryIdToVerify.toStr(ctx, buffer, "QueryIdToVerify", "", true, "", "");
	m_QueriesToVerify.toStr(ctx, buffer, "QueriesToVerify", "Item");
	m_CheckDFS.toStr(ctx, buffer, "CheckDFS", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
}


void CValidatePackageRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CValidatePackageRequest::serializer(IEspContext* ctx, IConstValidatePackageRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ValidatePackageRequest>");
	// field Info
	{
		const char* s = src.getInfo();
		if (s && *s)
		{
			buffer.append("<Info>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Info>");
		}
	}
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field Active
	{
		bool b = src.getActive();
		if (b)
			buffer.appendf("<Active>1</Active>");
	}
	// field PMID
	{
		const char* s = src.getPMID();
		if (s && *s)
		{
			buffer.append("<PMID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PMID>");
		}
	}
	// field QueryIdToVerify
	{
		const char* s = src.getQueryIdToVerify();
		if (s && *s)
		{
			buffer.append("<QueryIdToVerify>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueryIdToVerify>");
		}
	}
	// field QueriesToVerify
	{
		StringArray& v = src.getQueriesToVerify();
		if (v.length()>0)
			buffer.append("<QueriesToVerify>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</QueriesToVerify>");
	}
	// field CheckDFS
	{
		bool b = src.getCheckDFS();
		if (b)
			buffer.appendf("<CheckDFS>1</CheckDFS>");
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	if (keepRootTag)
		buffer.append("</ValidatePackageRequest>");
}

bool CValidatePackageRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Info.unmarshall(rpc_request, "Info", basepath);
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_Active.unmarshall(rpc_request, "Active", basepath);
	hasValue |= m_PMID.unmarshall(rpc_request, "PMID", basepath);
	hasValue |= m_QueryIdToVerify.unmarshall(rpc_request, "QueryIdToVerify", basepath);
	hasValue |= m_QueriesToVerify.unmarshall(rpc_request, "QueriesToVerify", basepath);
	hasValue |= m_CheckDFS.unmarshall(rpc_request, "CheckDFS", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	return hasValue;
}

bool CValidatePackageRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Info.unmarshall(ctx, soapval, "Info");
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_Active.unmarshall(ctx, soapval, "Active");
	hasValue |= m_PMID.unmarshall(ctx, soapval, "PMID");
	hasValue |= m_QueryIdToVerify.unmarshall(ctx, soapval, "QueryIdToVerify");
	hasValue |= m_QueriesToVerify.unmarshall(ctx, soapval, "QueriesToVerify");
	hasValue |= m_CheckDFS.unmarshall(ctx, soapval, "CheckDFS");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	return hasValue;
}

bool CValidatePackageRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Info.unmarshall(ctx, params, attachments, "Info", basepath);
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_Active.unmarshall(ctx, params, attachments, "Active", basepath);
	hasValue |= m_PMID.unmarshall(ctx, params, attachments, "PMID", basepath);
	hasValue |= m_QueryIdToVerify.unmarshall(ctx, params, attachments, "QueryIdToVerify", basepath);
	hasValue |= m_QueriesToVerify.unmarshall(ctx, params, attachments, "QueriesToVerify", basepath);
	hasValue |= m_CheckDFS.unmarshall(ctx, params, attachments, "CheckDFS", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	return hasValue;
}

const char * CValidatePackageRequest::getInfo() { return m_Info.query();}
const char * CValidatePackageRequest::getTarget() { return m_Target.query();}
const char * CValidatePackageRequest::getProcess() { return m_Process.query();}
bool CValidatePackageRequest::getActive() { return m_Active;}
const char * CValidatePackageRequest::getPMID() { return m_PMID.query();}
const char * CValidatePackageRequest::getQueryIdToVerify() { return m_QueryIdToVerify.query();}
StringArray & CValidatePackageRequest::getQueriesToVerify() { return (StringArray &) m_QueriesToVerify; }
bool CValidatePackageRequest::getCheckDFS() { return m_CheckDFS;}
bool CValidatePackageRequest::getGlobalScope() { return m_GlobalScope;}
void CValidatePackageRequest::setInfo(const char * val){ m_Info.set(val); }
void CValidatePackageRequest::setTarget(const char * val){ m_Target.set(val); }
void CValidatePackageRequest::setProcess(const char * val){ m_Process.set(val); }
void CValidatePackageRequest::setActive(bool val){ m_Active=val; }
void CValidatePackageRequest::setPMID(const char * val){ m_PMID.set(val); }
void CValidatePackageRequest::setQueryIdToVerify(const char * val){ m_QueryIdToVerify.set(val); }
void CValidatePackageRequest::setQueriesToVerify(StringArray &val){ m_QueriesToVerify->kill();  CloneArray(m_QueriesToVerify.getValue(), val); }
void CValidatePackageRequest::setCheckDFS(bool val){ m_CheckDFS=val; }
void CValidatePackageRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
extern "C"  IEspValidatePackageRequest *createValidatePackageRequest(const char *serv){return ((IEspValidatePackageRequest *)new CValidatePackageRequest(serv));}
extern "C"  IClientValidatePackageRequest *createClientValidatePackageRequest(const char *serv){return ((IClientValidatePackageRequest *)new CValidatePackageRequest(serv));}

//=======================================================
// class CValidatePackageInfo Implementation
//=======================================================

CValidatePackageInfo::CValidatePackageInfo(const char *serviceName, IRpcMessageBinding *init)
	: m_Unmatched(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageInfo");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CValidatePackageInfo::CValidatePackageInfo(const char *serviceName, const char *bc)
	: m_Unmatched(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageInfo");
}

StringBuffer &CValidatePackageInfo::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Unmatched\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CValidatePackageInfo::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CValidatePackageInfo::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CValidatePackageInfo::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Unmatched");
	form.appendf("<tr><td><b>Unmatched: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CValidatePackageInfo::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CValidatePackageInfo::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Unmatched.marshall(rpc_resp, "Unmatched", "Item");
}


void CValidatePackageInfo::copy(CValidatePackageInfo &from)
{
	m_Unmatched.copy(from.m_Unmatched);
}


void CValidatePackageInfo::copy(IConstValidatePackageInfo &ifrom)
{
	setUnmatched(ifrom.getUnmatched());
}


void CValidatePackageInfo::getAttributes(IProperties &attributes)
{
}


void CValidatePackageInfo::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Unmatched.toStr(ctx, buffer, "Unmatched", "Item");
}


void CValidatePackageInfo::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CValidatePackageInfo::serializer(IEspContext* ctx, IConstValidatePackageInfo &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ValidatePackageInfo>");
	// field Unmatched
	{
		StringArray& v = src.getUnmatched();
		if (v.length()>0)
			buffer.append("<Unmatched>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Unmatched>");
	}
	if (keepRootTag)
		buffer.append("</ValidatePackageInfo>");
}

bool CValidatePackageInfo::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(rpc_request, "Unmatched", basepath);
	return hasValue;
}

bool CValidatePackageInfo::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(ctx, soapval, "Unmatched");
	return hasValue;
}

bool CValidatePackageInfo::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(ctx, params, attachments, "Unmatched", basepath);
	return hasValue;
}

StringArray & CValidatePackageInfo::getUnmatched() { return (StringArray &) m_Unmatched; }
void CValidatePackageInfo::setUnmatched(StringArray &val){ m_Unmatched->kill();  CloneArray(m_Unmatched.getValue(), val); }
extern "C"  IEspValidatePackageInfo *createValidatePackageInfo(const char *serv, const char *msgname){return ((IEspValidatePackageInfo *)new CValidatePackageInfo(serv /*, msgname*/));}
extern "C"  IClientValidatePackageInfo *createClientValidatePackageInfo(const char *serv, const char *msgname){return ((IClientValidatePackageInfo *)new CValidatePackageInfo(serv /*, msgname*/));}

//=======================================================
// class CValidatePackageQueries Implementation
//=======================================================

CValidatePackageQueries::CValidatePackageQueries(const char *serviceName, IRpcMessageBinding *init)
	: m_Unmatched(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageQueries");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CValidatePackageQueries::CValidatePackageQueries(const char *serviceName, const char *bc)
	: m_Unmatched(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageQueries");
}

StringBuffer &CValidatePackageQueries::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Unmatched\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CValidatePackageQueries::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CValidatePackageQueries::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CValidatePackageQueries::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Unmatched");
	form.appendf("<tr><td><b>Unmatched: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CValidatePackageQueries::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CValidatePackageQueries::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Unmatched.marshall(rpc_resp, "Unmatched", "Item");
}


void CValidatePackageQueries::copy(CValidatePackageQueries &from)
{
	m_Unmatched.copy(from.m_Unmatched);
}


void CValidatePackageQueries::copy(IConstValidatePackageQueries &ifrom)
{
	setUnmatched(ifrom.getUnmatched());
}


void CValidatePackageQueries::getAttributes(IProperties &attributes)
{
}


void CValidatePackageQueries::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Unmatched.toStr(ctx, buffer, "Unmatched", "Item");
}


void CValidatePackageQueries::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CValidatePackageQueries::serializer(IEspContext* ctx, IConstValidatePackageQueries &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ValidatePackageQueries>");
	// field Unmatched
	{
		StringArray& v = src.getUnmatched();
		if (v.length()>0)
			buffer.append("<Unmatched>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Unmatched>");
	}
	if (keepRootTag)
		buffer.append("</ValidatePackageQueries>");
}

bool CValidatePackageQueries::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(rpc_request, "Unmatched", basepath);
	return hasValue;
}

bool CValidatePackageQueries::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(ctx, soapval, "Unmatched");
	return hasValue;
}

bool CValidatePackageQueries::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(ctx, params, attachments, "Unmatched", basepath);
	return hasValue;
}

StringArray & CValidatePackageQueries::getUnmatched() { return (StringArray &) m_Unmatched; }
void CValidatePackageQueries::setUnmatched(StringArray &val){ m_Unmatched->kill();  CloneArray(m_Unmatched.getValue(), val); }
extern "C"  IEspValidatePackageQueries *createValidatePackageQueries(const char *serv, const char *msgname){return ((IEspValidatePackageQueries *)new CValidatePackageQueries(serv /*, msgname*/));}
extern "C"  IClientValidatePackageQueries *createClientValidatePackageQueries(const char *serv, const char *msgname){return ((IClientValidatePackageQueries *)new CValidatePackageQueries(serv /*, msgname*/));}

//=======================================================
// class CValidatePackageFiles Implementation
//=======================================================

CValidatePackageFiles::CValidatePackageFiles(const char *serviceName, IRpcMessageBinding *init)
	: m_Unmatched(nilIgnore),m_NotInDFS(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageFiles");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CValidatePackageFiles::CValidatePackageFiles(const char *serviceName, const char *bc)
	: m_Unmatched(nilIgnore),m_NotInDFS(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageFiles");
}

StringBuffer &CValidatePackageFiles::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Unmatched\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"NotInDFS\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"File\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CValidatePackageFiles::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CValidatePackageFiles::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CValidatePackageFiles::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Unmatched");
	form.appendf("<tr><td><b>Unmatched: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("NotInDFS");
	form.appendf("<tr><td><b>NotInDFS: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CValidatePackageFiles::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CValidatePackageFiles::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Unmatched.marshall(rpc_resp, "Unmatched", "Item");
	m_NotInDFS.marshall(rpc_resp, "NotInDFS", "File");
}


void CValidatePackageFiles::copy(CValidatePackageFiles &from)
{
	m_Unmatched.copy(from.m_Unmatched);
	m_NotInDFS.copy(from.m_NotInDFS);
}


void CValidatePackageFiles::copy(IConstValidatePackageFiles &ifrom)
{
	setUnmatched(ifrom.getUnmatched());
	setNotInDFS(ifrom.getNotInDFS());
}


void CValidatePackageFiles::getAttributes(IProperties &attributes)
{
}


void CValidatePackageFiles::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Unmatched.toStr(ctx, buffer, "Unmatched", "Item");
	m_NotInDFS.toStr(ctx, buffer, "NotInDFS", "File");
}


void CValidatePackageFiles::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CValidatePackageFiles::serializer(IEspContext* ctx, IConstValidatePackageFiles &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ValidatePackageFiles>");
	// field Unmatched
	{
		StringArray& v = src.getUnmatched();
		if (v.length()>0)
			buffer.append("<Unmatched>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Unmatched>");
	}
	// field NotInDFS
	{
		StringArray& v = src.getNotInDFS();
		if (v.length()>0)
			buffer.append("<NotInDFS>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<File>%s</File>",v.item(i));
		if (v.length()>0)
			buffer.append("</NotInDFS>");
	}
	if (keepRootTag)
		buffer.append("</ValidatePackageFiles>");
}

bool CValidatePackageFiles::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(rpc_request, "Unmatched", basepath);
	hasValue |= m_NotInDFS.unmarshall(rpc_request, "NotInDFS", basepath);
	return hasValue;
}

bool CValidatePackageFiles::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(ctx, soapval, "Unmatched");
	hasValue |= m_NotInDFS.unmarshall(ctx, soapval, "NotInDFS");
	return hasValue;
}

bool CValidatePackageFiles::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Unmatched.unmarshall(ctx, params, attachments, "Unmatched", basepath);
	hasValue |= m_NotInDFS.unmarshall(ctx, params, attachments, "NotInDFS", basepath);
	return hasValue;
}

StringArray & CValidatePackageFiles::getUnmatched() { return (StringArray &) m_Unmatched; }
StringArray & CValidatePackageFiles::getNotInDFS() { return (StringArray &) m_NotInDFS; }
void CValidatePackageFiles::setUnmatched(StringArray &val){ m_Unmatched->kill();  CloneArray(m_Unmatched.getValue(), val); }
void CValidatePackageFiles::setNotInDFS(StringArray &val){ m_NotInDFS->kill();  CloneArray(m_NotInDFS.getValue(), val); }
extern "C"  IEspValidatePackageFiles *createValidatePackageFiles(const char *serv, const char *msgname){return ((IEspValidatePackageFiles *)new CValidatePackageFiles(serv /*, msgname*/));}
extern "C"  IClientValidatePackageFiles *createClientValidatePackageFiles(const char *serv, const char *msgname){return ((IClientValidatePackageFiles *)new CValidatePackageFiles(serv /*, msgname*/));}

//=======================================================
// class CValidatePackageResponse Implementation
//=======================================================

CValidatePackageResponse::CValidatePackageResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_PMID(nilIgnore),m_status(serviceName, nilIgnore),m_Warnings(nilIgnore),m_Errors(nilIgnore),m_packages(serviceName, nilIgnore),m_queries(serviceName, nilIgnore),m_files(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CValidatePackageResponse::CValidatePackageResponse(const char *serviceName, const char *bc)
	: m_PMID(nilIgnore),m_status(serviceName, nilIgnore),m_Warnings(nilIgnore),m_Errors(nilIgnore),m_packages(serviceName, nilIgnore),m_queries(serviceName, nilIgnore),m_files(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageResponse");
}

CValidatePackageResponse::CValidatePackageResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_PMID(nilIgnore),m_status(serviceName, nilIgnore),m_Warnings(nilIgnore),m_Errors(nilIgnore),m_packages(serviceName, nilIgnore),m_queries(serviceName, nilIgnore),m_files(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CValidatePackageResponse::CValidatePackageResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_PMID(nilIgnore),m_status(serviceName, nilIgnore),m_Warnings(nilIgnore),m_Errors(nilIgnore),m_packages(serviceName, nilIgnore),m_queries(serviceName, nilIgnore),m_files(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ValidatePackageResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CValidatePackageResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"PMID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Warnings\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Errors\" type=\"tns:EspStringArray\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"packages\" type=\"tns:ValidatePackageInfo\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"queries\" type=\"tns:ValidatePackageQueries\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"files\" type=\"tns:ValidatePackageFiles\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
		CValidatePackageInfo::getXsdDefinition(context, request, schema, added);
		CValidatePackageQueries::getXsdDefinition(context, request, schema, added);
		CValidatePackageFiles::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CValidatePackageResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CValidatePackageResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
	if (!added.getValue("ValidatePackageFiles"))
	{
		added.setValue("ValidatePackageFiles",1);
		CValidatePackageFiles::getMapInfo(info,added);
	}
	if (!added.getValue("ValidatePackageInfo"))
	{
		added.setValue("ValidatePackageInfo",1);
		CValidatePackageInfo::getMapInfo(info,added);
	}
	if (!added.getValue("ValidatePackageQueries"))
	{
		added.setValue("ValidatePackageQueries",1);
		CValidatePackageQueries::getMapInfo(info,added);
	}
}

StringBuffer &CValidatePackageResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PMID");
	form.appendf("  <tr><td><b>PMID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Warnings");
	form.appendf("<tr><td><b>Warnings: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Errors");
	form.appendf("<tr><td><b>Errors: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("packages");
	form.append("<tr>").append("<td><b>packages: </b></td><td><hr/>");
	CValidatePackageInfo::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("queries");
	form.append("<tr>").append("<td><b>queries: </b></td><td><hr/>");
	CValidatePackageQueries::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("files");
	form.append("<tr>").append("<td><b>files: </b></td><td><hr/>");
	CValidatePackageFiles::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CValidatePackageResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CValidatePackageResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_PMID.marshall(rpc_resp, "PMID", "", "", "");
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_Warnings.marshall(rpc_resp, "Warnings", "Item");
		m_Errors.marshall(rpc_resp, "Errors", "Item");
		m_packages.marshall(rpc_resp, "packages", "", "", "");
		m_queries.marshall(rpc_resp, "queries", "", "", "");
		m_files.marshall(rpc_resp, "files", "", "", "");
	}
}


void CValidatePackageResponse::copy(CValidatePackageResponse &from)
{
	m_PMID.copy(from.m_PMID);
	m_status.copy(from.m_status);
	m_Warnings.copy(from.m_Warnings);
	m_Errors.copy(from.m_Errors);
	m_packages.copy(from.m_packages);
	m_queries.copy(from.m_queries);
	m_files.copy(from.m_files);
}


void CValidatePackageResponse::copy(IConstValidatePackageResponse &ifrom)
{
	setPMID(ifrom.getPMID());
	setStatus(ifrom.getStatus());
	setWarnings(ifrom.getWarnings());
	setErrors(ifrom.getErrors());
	setPackages(ifrom.getPackages());
	setQueries(ifrom.getQueries());
	setFiles(ifrom.getFiles());
}


void CValidatePackageResponse::getAttributes(IProperties &attributes)
{
}


void CValidatePackageResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_PMID.toStr(ctx, buffer, "PMID", "", true, "", "");
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_Warnings.toStr(ctx, buffer, "Warnings", "Item");
		m_Errors.toStr(ctx, buffer, "Errors", "Item");
		m_packages.toStr(ctx, buffer, "packages", "", false, "", "");
		m_queries.toStr(ctx, buffer, "queries", "", false, "", "");
		m_files.toStr(ctx, buffer, "files", "", false, "", "");
	}
}


void CValidatePackageResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CValidatePackageResponse::serializer(IEspContext* ctx, IConstValidatePackageResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ValidatePackageResponse>");
	// field PMID
	{
		const char* s = src.getPMID();
		if (s && *s)
		{
			buffer.append("<PMID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PMID>");
		}
	}
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field Warnings
	{
		StringArray& v = src.getWarnings();
		if (v.length()>0)
			buffer.append("<Warnings>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Warnings>");
	}
	// field Errors
	{
		StringArray& v = src.getErrors();
		if (v.length()>0)
			buffer.append("<Errors>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Errors>");
	}
	// field packages
	{
		StringBuffer tmp;
		CValidatePackageInfo::serializer(ctx,src.getPackages(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<packages>%s</packages>",tmp.str());
	}
	// field queries
	{
		StringBuffer tmp;
		CValidatePackageQueries::serializer(ctx,src.getQueries(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<queries>%s</queries>",tmp.str());
	}
	// field files
	{
		StringBuffer tmp;
		CValidatePackageFiles::serializer(ctx,src.getFiles(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<files>%s</files>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</ValidatePackageResponse>");
}

bool CValidatePackageResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_PMID.unmarshall(rpc_request, "PMID", basepath);
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_Warnings.unmarshall(rpc_request, "Warnings", basepath);
		hasValue |= m_Errors.unmarshall(rpc_request, "Errors", basepath);
		hasValue |= m_packages.unmarshall(rpc_request, "packages", basepath);
		hasValue |= m_queries.unmarshall(rpc_request, "queries", basepath);
		hasValue |= m_files.unmarshall(rpc_request, "files", basepath);
	}
	return hasValue;
}

bool CValidatePackageResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_PMID.unmarshall(ctx, soapval, "PMID");
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_Warnings.unmarshall(ctx, soapval, "Warnings");
	hasValue |= m_Errors.unmarshall(ctx, soapval, "Errors");
	hasValue |= m_packages.unmarshall(ctx, soapval, "packages");
	hasValue |= m_queries.unmarshall(ctx, soapval, "queries");
	hasValue |= m_files.unmarshall(ctx, soapval, "files");
	return hasValue;
}

bool CValidatePackageResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_PMID.unmarshall(ctx, params, attachments, "PMID", basepath);
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_Warnings.unmarshall(ctx, params, attachments, "Warnings", basepath);
	hasValue |= m_Errors.unmarshall(ctx, params, attachments, "Errors", basepath);
	hasValue |= m_packages.unmarshall(ctx, params, attachments, "packages", basepath);
	hasValue |= m_queries.unmarshall(ctx, params, attachments, "queries", basepath);
	hasValue |= m_files.unmarshall(ctx, params, attachments, "files", basepath);
	return hasValue;
}

const char * CValidatePackageResponse::getPMID() { return m_PMID.query();}
IConstBasePackageStatus & CValidatePackageResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
StringArray & CValidatePackageResponse::getWarnings() { return (StringArray &) m_Warnings; }
StringArray & CValidatePackageResponse::getErrors() { return (StringArray &) m_Errors; }
IConstValidatePackageInfo & CValidatePackageResponse::getPackages() { return (IConstValidatePackageInfo &) m_packages.getValue();}
IConstValidatePackageQueries & CValidatePackageResponse::getQueries() { return (IConstValidatePackageQueries &) m_queries.getValue();}
IConstValidatePackageFiles & CValidatePackageResponse::getFiles() { return (IConstValidatePackageFiles &) m_files.getValue();}
void CValidatePackageResponse::setPMID(const char * val){ m_PMID.set(val); }
IEspBasePackageStatus & CValidatePackageResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CValidatePackageResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CValidatePackageResponse::setWarnings(StringArray &val){ m_Warnings->kill();  CloneArray(m_Warnings.getValue(), val); }
void CValidatePackageResponse::setErrors(StringArray &val){ m_Errors->kill();  CloneArray(m_Errors.getValue(), val); }
IEspValidatePackageInfo & CValidatePackageResponse::updatePackages(){ return (IEspValidatePackageInfo &) m_packages.getValue(); }
void CValidatePackageResponse::setPackages(IConstValidatePackageInfo &ifrom){ m_packages.copy(ifrom); }
IEspValidatePackageQueries & CValidatePackageResponse::updateQueries(){ return (IEspValidatePackageQueries &) m_queries.getValue(); }
void CValidatePackageResponse::setQueries(IConstValidatePackageQueries &ifrom){ m_queries.copy(ifrom); }
IEspValidatePackageFiles & CValidatePackageResponse::updateFiles(){ return (IEspValidatePackageFiles &) m_files.getValue(); }
void CValidatePackageResponse::setFiles(IConstValidatePackageFiles &ifrom){ m_files.copy(ifrom); }
extern "C"  IEspValidatePackageResponse *createValidatePackageResponse(const char *serv){return ((IEspValidatePackageResponse *)new CValidatePackageResponse(serv));}
extern "C"  IClientValidatePackageResponse *createClientValidatePackageResponse(const char *serv){return ((IClientValidatePackageResponse *)new CValidatePackageResponse(serv));}

//=======================================================
// class CGetQueryFileMappingRequest Implementation
//=======================================================

CGetQueryFileMappingRequest::CGetQueryFileMappingRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_PMID(nilIgnore),m_QueryName(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetQueryFileMappingRequest::CGetQueryFileMappingRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_PMID(nilIgnore),m_QueryName(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingRequest");
}

CGetQueryFileMappingRequest::CGetQueryFileMappingRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_PMID(nilIgnore),m_QueryName(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetQueryFileMappingRequest::CGetQueryFileMappingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_PMID(nilIgnore),m_QueryName(nilIgnore),m_GlobalScope(0, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetQueryFileMappingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PMID\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"QueryName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetQueryFileMappingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetQueryFileMappingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetQueryFileMappingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PMID");
	form.appendf("  <tr><td><b>PMID: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("QueryName");
	form.appendf("  <tr><td><b>QueryName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetQueryFileMappingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetQueryFileMappingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_PMID.marshall(rpc_resp, "PMID", "", "", "");
	m_QueryName.marshall(rpc_resp, "QueryName", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
}


void CGetQueryFileMappingRequest::copy(CGetQueryFileMappingRequest &from)
{
	m_Target.copy(from.m_Target);
	m_PMID.copy(from.m_PMID);
	m_QueryName.copy(from.m_QueryName);
	m_GlobalScope.copy(from.m_GlobalScope);
}


void CGetQueryFileMappingRequest::copy(IConstGetQueryFileMappingRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setPMID(ifrom.getPMID());
	setQueryName(ifrom.getQueryName());
	setGlobalScope(ifrom.getGlobalScope());
}


void CGetQueryFileMappingRequest::getAttributes(IProperties &attributes)
{
}


void CGetQueryFileMappingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_PMID.toStr(ctx, buffer, "PMID", "", true, "", "");
	m_QueryName.toStr(ctx, buffer, "QueryName", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
}


void CGetQueryFileMappingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetQueryFileMappingRequest::serializer(IEspContext* ctx, IConstGetQueryFileMappingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetQueryFileMappingRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field PMID
	{
		const char* s = src.getPMID();
		if (s && *s)
		{
			buffer.append("<PMID>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PMID>");
		}
	}
	// field QueryName
	{
		const char* s = src.getQueryName();
		if (s && *s)
		{
			buffer.append("<QueryName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</QueryName>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	if (keepRootTag)
		buffer.append("</GetQueryFileMappingRequest>");
}

bool CGetQueryFileMappingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_PMID.unmarshall(rpc_request, "PMID", basepath);
	hasValue |= m_QueryName.unmarshall(rpc_request, "QueryName", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	return hasValue;
}

bool CGetQueryFileMappingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_PMID.unmarshall(ctx, soapval, "PMID");
	hasValue |= m_QueryName.unmarshall(ctx, soapval, "QueryName");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	return hasValue;
}

bool CGetQueryFileMappingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_PMID.unmarshall(ctx, params, attachments, "PMID", basepath);
	hasValue |= m_QueryName.unmarshall(ctx, params, attachments, "QueryName", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	return hasValue;
}

const char * CGetQueryFileMappingRequest::getTarget() { return m_Target.query();}
const char * CGetQueryFileMappingRequest::getPMID() { return m_PMID.query();}
const char * CGetQueryFileMappingRequest::getQueryName() { return m_QueryName.query();}
bool CGetQueryFileMappingRequest::getGlobalScope() { return m_GlobalScope;}
void CGetQueryFileMappingRequest::setTarget(const char * val){ m_Target.set(val); }
void CGetQueryFileMappingRequest::setPMID(const char * val){ m_PMID.set(val); }
void CGetQueryFileMappingRequest::setQueryName(const char * val){ m_QueryName.set(val); }
void CGetQueryFileMappingRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
extern "C"  IEspGetQueryFileMappingRequest *createGetQueryFileMappingRequest(const char *serv){return ((IEspGetQueryFileMappingRequest *)new CGetQueryFileMappingRequest(serv));}
extern "C"  IClientGetQueryFileMappingRequest *createClientGetQueryFileMappingRequest(const char *serv){return ((IClientGetQueryFileMappingRequest *)new CGetQueryFileMappingRequest(serv));}

//=======================================================
// class CSuperFile Implementation
//=======================================================

CSuperFile::CSuperFile(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_SubFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SuperFile");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CSuperFile::CSuperFile(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_SubFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("SuperFile");
}

StringBuffer &CSuperFile::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SubFiles\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"File\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	return schema;
}

void CSuperFile::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CSuperFile::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CSuperFile::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SubFiles");
	form.appendf("<tr><td><b>SubFiles: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CSuperFile::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CSuperFile::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_SubFiles.marshall(rpc_resp, "SubFiles", "File");
}


void CSuperFile::copy(CSuperFile &from)
{
	m_Name.copy(from.m_Name);
	m_SubFiles.copy(from.m_SubFiles);
}


void CSuperFile::copy(IConstSuperFile &ifrom)
{
	setName(ifrom.getName());
	setSubFiles(ifrom.getSubFiles());
}


void CSuperFile::getAttributes(IProperties &attributes)
{
}


void CSuperFile::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_SubFiles.toStr(ctx, buffer, "SubFiles", "File");
}


void CSuperFile::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CSuperFile::serializer(IEspContext* ctx, IConstSuperFile &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<SuperFile>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field SubFiles
	{
		StringArray& v = src.getSubFiles();
		if (v.length()>0)
			buffer.append("<SubFiles>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<File>%s</File>",v.item(i));
		if (v.length()>0)
			buffer.append("</SubFiles>");
	}
	if (keepRootTag)
		buffer.append("</SuperFile>");
}

bool CSuperFile::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_SubFiles.unmarshall(rpc_request, "SubFiles", basepath);
	return hasValue;
}

bool CSuperFile::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_SubFiles.unmarshall(ctx, soapval, "SubFiles");
	return hasValue;
}

bool CSuperFile::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_SubFiles.unmarshall(ctx, params, attachments, "SubFiles", basepath);
	return hasValue;
}

const char * CSuperFile::getName() { return m_Name.query();}
StringArray & CSuperFile::getSubFiles() { return (StringArray &) m_SubFiles; }
void CSuperFile::setName(const char * val){ m_Name.set(val); }
void CSuperFile::setSubFiles(StringArray &val){ m_SubFiles->kill();  CloneArray(m_SubFiles.getValue(), val); }
extern "C"  IEspSuperFile *createSuperFile(const char *serv, const char *msgname){return ((IEspSuperFile *)new CSuperFile(serv /*, msgname*/));}
extern "C"  IClientSuperFile *createClientSuperFile(const char *serv, const char *msgname){return ((IClientSuperFile *)new CSuperFile(serv /*, msgname*/));}

//=======================================================
// class CGetQueryFileMappingResponse Implementation
//=======================================================

CGetQueryFileMappingResponse::CGetQueryFileMappingResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_UnmappedFiles(nilIgnore),m_SuperFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetQueryFileMappingResponse::CGetQueryFileMappingResponse(const char *serviceName, const char *bc)
	: m_UnmappedFiles(nilIgnore),m_SuperFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingResponse");
}

CGetQueryFileMappingResponse::CGetQueryFileMappingResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_UnmappedFiles(nilIgnore),m_SuperFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetQueryFileMappingResponse::CGetQueryFileMappingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_UnmappedFiles(nilIgnore),m_SuperFiles(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetQueryFileMappingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetQueryFileMappingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"UnmappedFiles\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"File\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SuperFiles\" type=\"tns:ArrayOfSuperFile\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CSuperFile::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("SuperFile") && added.getValue("ArrayOfSuperFile")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfSuperFile\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SuperFile\" type=\"tns:SuperFile\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfSuperFile",1);
	}
	return schema;
}

void CGetQueryFileMappingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetQueryFileMappingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("SuperFile"))
	{
		added.setValue("SuperFile",1);
		CSuperFile::getMapInfo(info,added);
	}
}

StringBuffer &CGetQueryFileMappingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UnmappedFiles");
	form.appendf("<tr><td><b>UnmappedFiles: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SuperFiles");
	form.appendf("<tr><td><b>SuperFiles: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetQueryFileMappingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetQueryFileMappingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_UnmappedFiles.marshall(rpc_resp, "UnmappedFiles", "File");
		m_SuperFiles.marshall(rpc_resp, "SuperFiles", "SuperFile");
	}
}


void CGetQueryFileMappingResponse::copy(CGetQueryFileMappingResponse &from)
{
	m_UnmappedFiles.copy(from.m_UnmappedFiles);
	m_SuperFiles.copy(from.m_SuperFiles);
}


void CGetQueryFileMappingResponse::copy(IConstGetQueryFileMappingResponse &ifrom)
{
	setUnmappedFiles(ifrom.getUnmappedFiles());
	setSuperFiles(ifrom.getSuperFiles());
}


void CGetQueryFileMappingResponse::getAttributes(IProperties &attributes)
{
}


void CGetQueryFileMappingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_UnmappedFiles.toStr(ctx, buffer, "UnmappedFiles", "File");
		m_SuperFiles.toStr(ctx, buffer, "SuperFiles", "SuperFile");
	}
}


void CGetQueryFileMappingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetQueryFileMappingResponse::serializer(IEspContext* ctx, IConstGetQueryFileMappingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetQueryFileMappingResponse>");
	// field UnmappedFiles
	{
		StringArray& v = src.getUnmappedFiles();
		if (v.length()>0)
			buffer.append("<UnmappedFiles>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<File>%s</File>",v.item(i));
		if (v.length()>0)
			buffer.append("</UnmappedFiles>");
	}
	// field SuperFiles
	{
		IArrayOf<IConstSuperFile>& v = src.getSuperFiles();
		int size = v.length();
		if (size>0)
			buffer.append("<SuperFiles>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CSuperFile::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</SuperFiles>");
	}
	if (keepRootTag)
		buffer.append("</GetQueryFileMappingResponse>");
}

bool CGetQueryFileMappingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_UnmappedFiles.unmarshall(rpc_request, "UnmappedFiles", basepath);
		hasValue |= m_SuperFiles.unmarshall(rpc_request, "SuperFiles", basepath);
	}
	return hasValue;
}

bool CGetQueryFileMappingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_UnmappedFiles.unmarshall(ctx, soapval, "UnmappedFiles");
	hasValue |= m_SuperFiles.unmarshall(ctx, soapval, "SuperFiles");
	return hasValue;
}

bool CGetQueryFileMappingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_UnmappedFiles.unmarshall(ctx, params, attachments, "UnmappedFiles", basepath);
	hasValue |= m_SuperFiles.unmarshall(ctx, params, attachments, "SuperFiles", basepath);
	return hasValue;
}

StringArray & CGetQueryFileMappingResponse::getUnmappedFiles() { return (StringArray &) m_UnmappedFiles; }
IArrayOf<IConstSuperFile> & CGetQueryFileMappingResponse::getSuperFiles() { return (IArrayOf<IConstSuperFile> &) m_SuperFiles; }
void CGetQueryFileMappingResponse::setUnmappedFiles(StringArray &val){ m_UnmappedFiles->kill();  CloneArray(m_UnmappedFiles.getValue(), val); }
void CGetQueryFileMappingResponse::setSuperFiles(IArrayOf<IEspSuperFile> &val)
{
	m_SuperFiles->kill();
	IArrayOf<IConstSuperFile> &target = m_SuperFiles.getValue();
	ForEachItemIn(idx, val)
	{
		IEspSuperFile &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetQueryFileMappingResponse::setSuperFiles(IArrayOf<IConstSuperFile> &val)
{
	m_SuperFiles->kill();
	IArrayOf<IConstSuperFile> &target = m_SuperFiles.getValue();
	ForEachItemIn(idx, val)
	{
		IConstSuperFile &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
extern "C"  IEspGetQueryFileMappingResponse *createGetQueryFileMappingResponse(const char *serv){return ((IEspGetQueryFileMappingResponse *)new CGetQueryFileMappingResponse(serv));}
extern "C"  IClientGetQueryFileMappingResponse *createClientGetQueryFileMappingResponse(const char *serv){return ((IClientGetQueryFileMappingResponse *)new CGetQueryFileMappingResponse(serv));}

//=======================================================
// class CTargetData Implementation
//=======================================================

CTargetData::CTargetData(const char *serviceName, IRpcMessageBinding *init)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Processes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetData");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CTargetData::CTargetData(const char *serviceName, const char *bc)
	: m_Name(nilIgnore),m_Type(nilIgnore),m_Processes(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("TargetData");
}

StringBuffer &CTargetData::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:complexType name=\"%s\">\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Name\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Type\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Processes\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType>\n");
		}
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	return schema;
}

void CTargetData::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CTargetData::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CTargetData::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Name");
	form.appendf("  <tr><td><b>Name: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Type");
	form.appendf("  <tr><td><b>Type: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Processes");
	form.appendf("<tr><td><b>Processes: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CTargetData::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CTargetData::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Name.marshall(rpc_resp, "Name", "", "", "");
	m_Type.marshall(rpc_resp, "Type", "", "", "");
	m_Processes.marshall(rpc_resp, "Processes", "Item");
}


void CTargetData::copy(CTargetData &from)
{
	m_Name.copy(from.m_Name);
	m_Type.copy(from.m_Type);
	m_Processes.copy(from.m_Processes);
}


void CTargetData::copy(IConstTargetData &ifrom)
{
	setName(ifrom.getName());
	setType(ifrom.getType());
	setProcesses(ifrom.getProcesses());
}


void CTargetData::getAttributes(IProperties &attributes)
{
}


void CTargetData::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Name.toStr(ctx, buffer, "Name", "", true, "", "");
	m_Type.toStr(ctx, buffer, "Type", "", true, "", "");
	m_Processes.toStr(ctx, buffer, "Processes", "Item");
}


void CTargetData::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CTargetData::serializer(IEspContext* ctx, IConstTargetData &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<TargetData>");
	// field Name
	{
		const char* s = src.getName();
		if (s && *s)
		{
			buffer.append("<Name>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Name>");
		}
	}
	// field Type
	{
		const char* s = src.getType();
		if (s && *s)
		{
			buffer.append("<Type>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Type>");
		}
	}
	// field Processes
	{
		StringArray& v = src.getProcesses();
		if (v.length()>0)
			buffer.append("<Processes>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</Processes>");
	}
	if (keepRootTag)
		buffer.append("</TargetData>");
}

bool CTargetData::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(rpc_request, "Name", basepath);
	hasValue |= m_Type.unmarshall(rpc_request, "Type", basepath);
	hasValue |= m_Processes.unmarshall(rpc_request, "Processes", basepath);
	return hasValue;
}

bool CTargetData::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, soapval, "Name");
	hasValue |= m_Type.unmarshall(ctx, soapval, "Type");
	hasValue |= m_Processes.unmarshall(ctx, soapval, "Processes");
	return hasValue;
}

bool CTargetData::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Name.unmarshall(ctx, params, attachments, "Name", basepath);
	hasValue |= m_Type.unmarshall(ctx, params, attachments, "Type", basepath);
	hasValue |= m_Processes.unmarshall(ctx, params, attachments, "Processes", basepath);
	return hasValue;
}

const char * CTargetData::getName() { return m_Name.query();}
const char * CTargetData::getType() { return m_Type.query();}
StringArray & CTargetData::getProcesses() { return (StringArray &) m_Processes; }
void CTargetData::setName(const char * val){ m_Name.set(val); }
void CTargetData::setType(const char * val){ m_Type.set(val); }
void CTargetData::setProcesses(StringArray &val){ m_Processes->kill();  CloneArray(m_Processes.getValue(), val); }
extern "C"  IEspTargetData *createTargetData(const char *serv, const char *msgname){return ((IEspTargetData *)new CTargetData(serv /*, msgname*/));}
extern "C"  IClientTargetData *createClientTargetData(const char *serv, const char *msgname){return ((IClientTargetData *)new CTargetData(serv /*, msgname*/));}

//=======================================================
// class CGetPackageMapSelectOptionsRequest Implementation
//=======================================================

CGetPackageMapSelectOptionsRequest::CGetPackageMapSelectOptionsRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_IncludeTargets(1, nilIgnore,false),m_IncludeProcesses(1, nilIgnore,false),m_IncludeProcessFilters(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPackageMapSelectOptionsRequest::CGetPackageMapSelectOptionsRequest(const char *serviceName, const char *bc)
	: m_IncludeTargets(1, nilIgnore,false),m_IncludeProcesses(1, nilIgnore,false),m_IncludeProcessFilters(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsRequest");
}

CGetPackageMapSelectOptionsRequest::CGetPackageMapSelectOptionsRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_IncludeTargets(1, nilIgnore,false),m_IncludeProcesses(1, nilIgnore,false),m_IncludeProcessFilters(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPackageMapSelectOptionsRequest::CGetPackageMapSelectOptionsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_IncludeTargets(1, nilIgnore,false),m_IncludeProcesses(1, nilIgnore,false),m_IncludeProcessFilters(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPackageMapSelectOptionsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"IncludeTargets\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"IncludeProcesses\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"IncludeProcessFilters\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetPackageMapSelectOptionsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPackageMapSelectOptionsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetPackageMapSelectOptionsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeTargets");
	
	form.appendf("  <tr><td><b>IncludeTargets? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeProcesses");
	
	form.appendf("  <tr><td><b>IncludeProcesses? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IncludeProcessFilters");
	
	form.appendf("  <tr><td><b>IncludeProcessFilters? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPackageMapSelectOptionsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPackageMapSelectOptionsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_IncludeTargets.marshall(rpc_resp, "IncludeTargets", "", "", "");
	m_IncludeProcesses.marshall(rpc_resp, "IncludeProcesses", "", "", "");
	m_IncludeProcessFilters.marshall(rpc_resp, "IncludeProcessFilters", "", "", "");
}


void CGetPackageMapSelectOptionsRequest::copy(CGetPackageMapSelectOptionsRequest &from)
{
	m_IncludeTargets.copy(from.m_IncludeTargets);
	m_IncludeProcesses.copy(from.m_IncludeProcesses);
	m_IncludeProcessFilters.copy(from.m_IncludeProcessFilters);
}


void CGetPackageMapSelectOptionsRequest::copy(IConstGetPackageMapSelectOptionsRequest &ifrom)
{
	setIncludeTargets(ifrom.getIncludeTargets());
	setIncludeProcesses(ifrom.getIncludeProcesses());
	setIncludeProcessFilters(ifrom.getIncludeProcessFilters());
}


void CGetPackageMapSelectOptionsRequest::getAttributes(IProperties &attributes)
{
}


void CGetPackageMapSelectOptionsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_IncludeTargets.toStr(ctx, buffer, "IncludeTargets", "", true, "", "");
	m_IncludeProcesses.toStr(ctx, buffer, "IncludeProcesses", "", true, "", "");
	m_IncludeProcessFilters.toStr(ctx, buffer, "IncludeProcessFilters", "", true, "", "");
}


void CGetPackageMapSelectOptionsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPackageMapSelectOptionsRequest::serializer(IEspContext* ctx, IConstGetPackageMapSelectOptionsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPackageMapSelectOptionsRequest>");
	// field IncludeTargets
	{
		bool b = src.getIncludeTargets();
		if (b)
			buffer.appendf("<IncludeTargets>1</IncludeTargets>");
	}
	// field IncludeProcesses
	{
		bool b = src.getIncludeProcesses();
		if (b)
			buffer.appendf("<IncludeProcesses>1</IncludeProcesses>");
	}
	// field IncludeProcessFilters
	{
		bool b = src.getIncludeProcessFilters();
		if (b)
			buffer.appendf("<IncludeProcessFilters>1</IncludeProcessFilters>");
	}
	if (keepRootTag)
		buffer.append("</GetPackageMapSelectOptionsRequest>");
}

bool CGetPackageMapSelectOptionsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_IncludeTargets.unmarshall(rpc_request, "IncludeTargets", basepath);
	hasValue |= m_IncludeProcesses.unmarshall(rpc_request, "IncludeProcesses", basepath);
	hasValue |= m_IncludeProcessFilters.unmarshall(rpc_request, "IncludeProcessFilters", basepath);
	return hasValue;
}

bool CGetPackageMapSelectOptionsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_IncludeTargets.unmarshall(ctx, soapval, "IncludeTargets");
	hasValue |= m_IncludeProcesses.unmarshall(ctx, soapval, "IncludeProcesses");
	hasValue |= m_IncludeProcessFilters.unmarshall(ctx, soapval, "IncludeProcessFilters");
	return hasValue;
}

bool CGetPackageMapSelectOptionsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_IncludeTargets.unmarshall(ctx, params, attachments, "IncludeTargets", basepath);
	hasValue |= m_IncludeProcesses.unmarshall(ctx, params, attachments, "IncludeProcesses", basepath);
	hasValue |= m_IncludeProcessFilters.unmarshall(ctx, params, attachments, "IncludeProcessFilters", basepath);
	return hasValue;
}

bool CGetPackageMapSelectOptionsRequest::getIncludeTargets() { return m_IncludeTargets;}
bool CGetPackageMapSelectOptionsRequest::getIncludeProcesses() { return m_IncludeProcesses;}
bool CGetPackageMapSelectOptionsRequest::getIncludeProcessFilters() { return m_IncludeProcessFilters;}
void CGetPackageMapSelectOptionsRequest::setIncludeTargets(bool val){ m_IncludeTargets=val; }
void CGetPackageMapSelectOptionsRequest::setIncludeProcesses(bool val){ m_IncludeProcesses=val; }
void CGetPackageMapSelectOptionsRequest::setIncludeProcessFilters(bool val){ m_IncludeProcessFilters=val; }
extern "C"  IEspGetPackageMapSelectOptionsRequest *createGetPackageMapSelectOptionsRequest(const char *serv){return ((IEspGetPackageMapSelectOptionsRequest *)new CGetPackageMapSelectOptionsRequest(serv));}
extern "C"  IClientGetPackageMapSelectOptionsRequest *createClientGetPackageMapSelectOptionsRequest(const char *serv){return ((IClientGetPackageMapSelectOptionsRequest *)new CGetPackageMapSelectOptionsRequest(serv));}

//=======================================================
// class CGetPackageMapSelectOptionsResponse Implementation
//=======================================================

CGetPackageMapSelectOptionsResponse::CGetPackageMapSelectOptionsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_Targets(nilIgnore),m_ProcessFilters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPackageMapSelectOptionsResponse::CGetPackageMapSelectOptionsResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_Targets(nilIgnore),m_ProcessFilters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsResponse");
}

CGetPackageMapSelectOptionsResponse::CGetPackageMapSelectOptionsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_Targets(nilIgnore),m_ProcessFilters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPackageMapSelectOptionsResponse::CGetPackageMapSelectOptionsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_Targets(nilIgnore),m_ProcessFilters(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPackageMapSelectOptionsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPackageMapSelectOptionsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Targets\" type=\"tns:ArrayOfTargetData\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ProcessFilters\" type=\"tns:EspStringArray\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
		CTargetData::getXsdDefinition(context, request, schema, added);
	}
	if (added.getValue("EspStringArray")==NULL) {
		addEspNativeArray(schema,"string","EspStringArray");
		added.setValue("EspStringArray",1);
	}
	if (added.getValue("TargetData") && added.getValue("ArrayOfTargetData")==NULL) {
		schema.append("<xsd:complexType name=\"ArrayOfTargetData\">\n");
		schema.append("<xsd:sequence>\n");
		schema.append("<xsd:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TargetData\" type=\"tns:TargetData\"/>\n");
		schema.append("</xsd:sequence>\n");
		schema.append("</xsd:complexType>\n");
		added.setValue("ArrayOfTargetData",1);
	}
	return schema;
}

void CGetPackageMapSelectOptionsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPackageMapSelectOptionsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
	if (!added.getValue("TargetData"))
	{
		added.setValue("TargetData",1);
		CTargetData::getMapInfo(info,added);
	}
}

StringBuffer &CGetPackageMapSelectOptionsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Targets");
	form.appendf("<tr><td><b>Targets: </b></td><td>");
	form.appendf("<table><tr><td><textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea></td>", extfix.str());
	form.append("</tr></table>");
	form.append("</td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ProcessFilters");
	form.appendf("<tr><td><b>ProcessFilters: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPackageMapSelectOptionsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPackageMapSelectOptionsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_Targets.marshall(rpc_resp, "Targets", "TargetData");
		m_ProcessFilters.marshall(rpc_resp, "ProcessFilters", "Item");
	}
}


void CGetPackageMapSelectOptionsResponse::copy(CGetPackageMapSelectOptionsResponse &from)
{
	m_status.copy(from.m_status);
	m_Targets.copy(from.m_Targets);
	m_ProcessFilters.copy(from.m_ProcessFilters);
}


void CGetPackageMapSelectOptionsResponse::copy(IConstGetPackageMapSelectOptionsResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setTargets(ifrom.getTargets());
	setProcessFilters(ifrom.getProcessFilters());
}


void CGetPackageMapSelectOptionsResponse::getAttributes(IProperties &attributes)
{
}


void CGetPackageMapSelectOptionsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_Targets.toStr(ctx, buffer, "Targets", "TargetData");
		m_ProcessFilters.toStr(ctx, buffer, "ProcessFilters", "Item");
	}
}


void CGetPackageMapSelectOptionsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPackageMapSelectOptionsResponse::serializer(IEspContext* ctx, IConstGetPackageMapSelectOptionsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPackageMapSelectOptionsResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field Targets
	{
		IArrayOf<IConstTargetData>& v = src.getTargets();
		int size = v.length();
		if (size>0)
			buffer.append("<Targets>");
		for (int i=0;i<size;i++)
		{
			buffer.append("<Item>");
			CTargetData::serializer(ctx,v.item(i),buffer,false);
			buffer.append("</Item>");
		}
		if (size>0)
			buffer.append("</Targets>");
	}
	// field ProcessFilters
	{
		StringArray& v = src.getProcessFilters();
		if (v.length()>0)
			buffer.append("<ProcessFilters>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<Item>%s</Item>",v.item(i));
		if (v.length()>0)
			buffer.append("</ProcessFilters>");
	}
	if (keepRootTag)
		buffer.append("</GetPackageMapSelectOptionsResponse>");
}

bool CGetPackageMapSelectOptionsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_Targets.unmarshall(rpc_request, "Targets", basepath);
		hasValue |= m_ProcessFilters.unmarshall(rpc_request, "ProcessFilters", basepath);
	}
	return hasValue;
}

bool CGetPackageMapSelectOptionsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_Targets.unmarshall(ctx, soapval, "Targets");
	hasValue |= m_ProcessFilters.unmarshall(ctx, soapval, "ProcessFilters");
	return hasValue;
}

bool CGetPackageMapSelectOptionsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_Targets.unmarshall(ctx, params, attachments, "Targets", basepath);
	hasValue |= m_ProcessFilters.unmarshall(ctx, params, attachments, "ProcessFilters", basepath);
	return hasValue;
}

IConstBasePackageStatus & CGetPackageMapSelectOptionsResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
IArrayOf<IConstTargetData> & CGetPackageMapSelectOptionsResponse::getTargets() { return (IArrayOf<IConstTargetData> &) m_Targets; }
StringArray & CGetPackageMapSelectOptionsResponse::getProcessFilters() { return (StringArray &) m_ProcessFilters; }
IEspBasePackageStatus & CGetPackageMapSelectOptionsResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CGetPackageMapSelectOptionsResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CGetPackageMapSelectOptionsResponse::setTargets(IArrayOf<IEspTargetData> &val)
{
	m_Targets->kill();
	IArrayOf<IConstTargetData> &target = m_Targets.getValue();
	ForEachItemIn(idx, val)
	{
		IEspTargetData &item = (val).item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetPackageMapSelectOptionsResponse::setTargets(IArrayOf<IConstTargetData> &val)
{
	m_Targets->kill();
	IArrayOf<IConstTargetData> &target = m_Targets.getValue();
	ForEachItemIn(idx, val)
	{
		IConstTargetData &item = val.item(idx);
		item.Link();
		target.append(item);
	}
}
void CGetPackageMapSelectOptionsResponse::setProcessFilters(StringArray &val){ m_ProcessFilters->kill();  CloneArray(m_ProcessFilters.getValue(), val); }
extern "C"  IEspGetPackageMapSelectOptionsResponse *createGetPackageMapSelectOptionsResponse(const char *serv){return ((IEspGetPackageMapSelectOptionsResponse *)new CGetPackageMapSelectOptionsResponse(serv));}
extern "C"  IClientGetPackageMapSelectOptionsResponse *createClientGetPackageMapSelectOptionsResponse(const char *serv){return ((IClientGetPackageMapSelectOptionsResponse *)new CGetPackageMapSelectOptionsResponse(serv));}

//=======================================================
// class CAddPartToPackageMapRequest Implementation
//=======================================================

CAddPartToPackageMapRequest::CAddPartToPackageMapRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_Process(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore),m_Content(nilIgnore),m_DeletePrevious(nilIgnore),m_DaliIp(nilIgnore),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddPartToPackageMapRequest::CAddPartToPackageMapRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_Process(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore),m_Content(nilIgnore),m_DeletePrevious(nilIgnore),m_DaliIp(nilIgnore),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapRequest");
}

CAddPartToPackageMapRequest::CAddPartToPackageMapRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_Process(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore),m_Content(nilIgnore),m_DeletePrevious(nilIgnore),m_DaliIp(nilIgnore),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddPartToPackageMapRequest::CAddPartToPackageMapRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_Process(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore),m_Content(nilIgnore),m_DeletePrevious(nilIgnore),m_DaliIp(nilIgnore),m_SourceProcess(nilIgnore),m_AllowForeignFiles(1, nilIgnore,false),m_PreloadAllPackages(0, nilIgnore,false),m_UpdateSuperFiles(0, nilIgnore,false),m_UpdateCloneFrom(0, nilIgnore,false),m_AppendCluster(1, nilIgnore,false)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddPartToPackageMapRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Process\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMap\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PartName\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Content\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DeletePrevious\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"DaliIp\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"SourceProcess\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"AllowForeignFiles\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"PreloadAllPackages\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UpdateSuperFiles\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"UpdateCloneFrom\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"true\" name=\"AppendCluster\" type=\"xsd:boolean\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CAddPartToPackageMapRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddPartToPackageMapRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CAddPartToPackageMapRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Process");
	form.appendf("  <tr><td><b>Process: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMap");
	form.appendf("  <tr><td><b>PackageMap: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PartName");
	form.appendf("  <tr><td><b>PartName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Content");
	form.appendf("  <tr><td><b>Content: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DeletePrevious");
	
	form.appendf("  <tr><td><b>DeletePrevious? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("DaliIp");
	form.appendf("  <tr><td><b>DaliIp: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("SourceProcess");
	form.appendf("  <tr><td><b>SourceProcess: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AllowForeignFiles");
	
	form.appendf("  <tr><td><b>AllowForeignFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PreloadAllPackages");
	
	form.appendf("  <tr><td><b>PreloadAllPackages? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateSuperFiles");
	
	form.appendf("  <tr><td><b>UpdateSuperFiles? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("UpdateCloneFrom");
	
	form.appendf("  <tr><td><b>UpdateCloneFrom? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("AppendCluster");
	
	form.appendf("  <tr><td><b>AppendCluster? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\" checked=\"1\" /></td></tr>\n", extfix.str());
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddPartToPackageMapRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddPartToPackageMapRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_Process.marshall(rpc_resp, "Process", "", "", "");
	m_PackageMap.marshall(rpc_resp, "PackageMap", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
	m_PartName.marshall(rpc_resp, "PartName", "", "", "");
	m_Content.marshall(rpc_resp, "Content", "", "", "");
	m_DeletePrevious.marshall(rpc_resp, "DeletePrevious", "", "", "");
	m_DaliIp.marshall(rpc_resp, "DaliIp", "", "", "");
	m_SourceProcess.marshall(rpc_resp, "SourceProcess", "", "", "");
	m_AllowForeignFiles.marshall(rpc_resp, "AllowForeignFiles", "", "", "");
	m_PreloadAllPackages.marshall(rpc_resp, "PreloadAllPackages", "", "", "");
	m_UpdateSuperFiles.marshall(rpc_resp, "UpdateSuperFiles", "", "", "");
	m_UpdateCloneFrom.marshall(rpc_resp, "UpdateCloneFrom", "", "", "");
	m_AppendCluster.marshall(rpc_resp, "AppendCluster", "", "", "");
}


void CAddPartToPackageMapRequest::copy(CAddPartToPackageMapRequest &from)
{
	m_Target.copy(from.m_Target);
	m_Process.copy(from.m_Process);
	m_PackageMap.copy(from.m_PackageMap);
	m_GlobalScope.copy(from.m_GlobalScope);
	m_PartName.copy(from.m_PartName);
	m_Content.copy(from.m_Content);
	m_DeletePrevious.copy(from.m_DeletePrevious);
	m_DaliIp.copy(from.m_DaliIp);
	m_SourceProcess.copy(from.m_SourceProcess);
	m_AllowForeignFiles.copy(from.m_AllowForeignFiles);
	m_PreloadAllPackages.copy(from.m_PreloadAllPackages);
	m_UpdateSuperFiles.copy(from.m_UpdateSuperFiles);
	m_UpdateCloneFrom.copy(from.m_UpdateCloneFrom);
	m_AppendCluster.copy(from.m_AppendCluster);
}


void CAddPartToPackageMapRequest::copy(IConstAddPartToPackageMapRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setProcess(ifrom.getProcess());
	setPackageMap(ifrom.getPackageMap());
	setGlobalScope(ifrom.getGlobalScope());
	setPartName(ifrom.getPartName());
	setContent(ifrom.getContent());
	setDeletePrevious(ifrom.getDeletePrevious());
	setDaliIp(ifrom.getDaliIp());
	setSourceProcess(ifrom.getSourceProcess());
	setAllowForeignFiles(ifrom.getAllowForeignFiles());
	setPreloadAllPackages(ifrom.getPreloadAllPackages());
	setUpdateSuperFiles(ifrom.getUpdateSuperFiles());
	setUpdateCloneFrom(ifrom.getUpdateCloneFrom());
	setAppendCluster(ifrom.getAppendCluster());
}


void CAddPartToPackageMapRequest::getAttributes(IProperties &attributes)
{
}


void CAddPartToPackageMapRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_Process.toStr(ctx, buffer, "Process", "", true, "", "");
	m_PackageMap.toStr(ctx, buffer, "PackageMap", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
	m_PartName.toStr(ctx, buffer, "PartName", "", true, "", "");
	m_Content.toStr(ctx, buffer, "Content", "", true, "", "");
	m_DeletePrevious.toStr(ctx, buffer, "DeletePrevious", "", true, "", "");
	m_DaliIp.toStr(ctx, buffer, "DaliIp", "", true, "", "");
	m_SourceProcess.toStr(ctx, buffer, "SourceProcess", "", true, "", "");
	m_AllowForeignFiles.toStr(ctx, buffer, "AllowForeignFiles", "", true, "", "");
	m_PreloadAllPackages.toStr(ctx, buffer, "PreloadAllPackages", "", true, "", "");
	m_UpdateSuperFiles.toStr(ctx, buffer, "UpdateSuperFiles", "", true, "", "");
	m_UpdateCloneFrom.toStr(ctx, buffer, "UpdateCloneFrom", "", true, "", "");
	m_AppendCluster.toStr(ctx, buffer, "AppendCluster", "", true, "", "");
}


void CAddPartToPackageMapRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddPartToPackageMapRequest::serializer(IEspContext* ctx, IConstAddPartToPackageMapRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddPartToPackageMapRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field Process
	{
		const char* s = src.getProcess();
		if (s && *s)
		{
			buffer.append("<Process>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Process>");
		}
	}
	// field PackageMap
	{
		const char* s = src.getPackageMap();
		if (s && *s)
		{
			buffer.append("<PackageMap>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMap>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	// field PartName
	{
		const char* s = src.getPartName();
		if (s && *s)
		{
			buffer.append("<PartName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PartName>");
		}
	}
	// field Content
	{
		const char* s = src.getContent();
		if (s && *s)
		{
			buffer.append("<Content>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Content>");
		}
	}
	// field DeletePrevious
	{
		bool b = src.getDeletePrevious();
		if (b)
			buffer.appendf("<DeletePrevious>1</DeletePrevious>");
	}
	// field DaliIp
	{
		const char* s = src.getDaliIp();
		if (s && *s)
		{
			buffer.append("<DaliIp>");
			encodeUtf8XML(s,buffer);
			buffer.append("</DaliIp>");
		}
	}
	// field SourceProcess
	{
		const char* s = src.getSourceProcess();
		if (s && *s)
		{
			buffer.append("<SourceProcess>");
			encodeUtf8XML(s,buffer);
			buffer.append("</SourceProcess>");
		}
	}
	// field AllowForeignFiles
	{
		bool b = src.getAllowForeignFiles();
		if (b)
			buffer.appendf("<AllowForeignFiles>1</AllowForeignFiles>");
	}
	// field PreloadAllPackages
	{
		bool b = src.getPreloadAllPackages();
		if (b)
			buffer.appendf("<PreloadAllPackages>1</PreloadAllPackages>");
	}
	// field UpdateSuperFiles
	{
		bool b = src.getUpdateSuperFiles();
		if (b)
			buffer.appendf("<UpdateSuperFiles>1</UpdateSuperFiles>");
	}
	// field UpdateCloneFrom
	{
		bool b = src.getUpdateCloneFrom();
		if (b)
			buffer.appendf("<UpdateCloneFrom>1</UpdateCloneFrom>");
	}
	// field AppendCluster
	{
		bool b = src.getAppendCluster();
		if (b)
			buffer.appendf("<AppendCluster>1</AppendCluster>");
	}
	if (keepRootTag)
		buffer.append("</AddPartToPackageMapRequest>");
}

bool CAddPartToPackageMapRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_Process.unmarshall(rpc_request, "Process", basepath);
	hasValue |= m_PackageMap.unmarshall(rpc_request, "PackageMap", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	hasValue |= m_PartName.unmarshall(rpc_request, "PartName", basepath);
	hasValue |= m_Content.unmarshall(rpc_request, "Content", basepath);
	hasValue |= m_DeletePrevious.unmarshall(rpc_request, "DeletePrevious", basepath);
	hasValue |= m_DaliIp.unmarshall(rpc_request, "DaliIp", basepath);
	hasValue |= m_SourceProcess.unmarshall(rpc_request, "SourceProcess", basepath);
	hasValue |= m_AllowForeignFiles.unmarshall(rpc_request, "AllowForeignFiles", basepath);
	hasValue |= m_PreloadAllPackages.unmarshall(rpc_request, "PreloadAllPackages", basepath);
	hasValue |= m_UpdateSuperFiles.unmarshall(rpc_request, "UpdateSuperFiles", basepath);
	hasValue |= m_UpdateCloneFrom.unmarshall(rpc_request, "UpdateCloneFrom", basepath);
	hasValue |= m_AppendCluster.unmarshall(rpc_request, "AppendCluster", basepath);
	return hasValue;
}

bool CAddPartToPackageMapRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_Process.unmarshall(ctx, soapval, "Process");
	hasValue |= m_PackageMap.unmarshall(ctx, soapval, "PackageMap");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	hasValue |= m_PartName.unmarshall(ctx, soapval, "PartName");
	hasValue |= m_Content.unmarshall(ctx, soapval, "Content");
	hasValue |= m_DeletePrevious.unmarshall(ctx, soapval, "DeletePrevious");
	hasValue |= m_DaliIp.unmarshall(ctx, soapval, "DaliIp");
	hasValue |= m_SourceProcess.unmarshall(ctx, soapval, "SourceProcess");
	hasValue |= m_AllowForeignFiles.unmarshall(ctx, soapval, "AllowForeignFiles");
	hasValue |= m_PreloadAllPackages.unmarshall(ctx, soapval, "PreloadAllPackages");
	hasValue |= m_UpdateSuperFiles.unmarshall(ctx, soapval, "UpdateSuperFiles");
	hasValue |= m_UpdateCloneFrom.unmarshall(ctx, soapval, "UpdateCloneFrom");
	hasValue |= m_AppendCluster.unmarshall(ctx, soapval, "AppendCluster");
	return hasValue;
}

bool CAddPartToPackageMapRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_Process.unmarshall(ctx, params, attachments, "Process", basepath);
	hasValue |= m_PackageMap.unmarshall(ctx, params, attachments, "PackageMap", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	hasValue |= m_PartName.unmarshall(ctx, params, attachments, "PartName", basepath);
	hasValue |= m_Content.unmarshall(ctx, params, attachments, "Content", basepath);
	hasValue |= m_DeletePrevious.unmarshall(ctx, params, attachments, "DeletePrevious", basepath);
	hasValue |= m_DaliIp.unmarshall(ctx, params, attachments, "DaliIp", basepath);
	hasValue |= m_SourceProcess.unmarshall(ctx, params, attachments, "SourceProcess", basepath);
	hasValue |= m_AllowForeignFiles.unmarshall(ctx, params, attachments, "AllowForeignFiles", basepath);
	hasValue |= m_PreloadAllPackages.unmarshall(ctx, params, attachments, "PreloadAllPackages", basepath);
	hasValue |= m_UpdateSuperFiles.unmarshall(ctx, params, attachments, "UpdateSuperFiles", basepath);
	hasValue |= m_UpdateCloneFrom.unmarshall(ctx, params, attachments, "UpdateCloneFrom", basepath);
	hasValue |= m_AppendCluster.unmarshall(ctx, params, attachments, "AppendCluster", basepath);
	return hasValue;
}

const char * CAddPartToPackageMapRequest::getTarget() { return m_Target.query();}
const char * CAddPartToPackageMapRequest::getProcess() { return m_Process.query();}
const char * CAddPartToPackageMapRequest::getPackageMap() { return m_PackageMap.query();}
bool CAddPartToPackageMapRequest::getGlobalScope() { return m_GlobalScope;}
const char * CAddPartToPackageMapRequest::getPartName() { return m_PartName.query();}
const char * CAddPartToPackageMapRequest::getContent() { return m_Content.query();}
bool CAddPartToPackageMapRequest::getDeletePrevious() { return m_DeletePrevious;}
const char * CAddPartToPackageMapRequest::getDaliIp() { return m_DaliIp.query();}
const char * CAddPartToPackageMapRequest::getSourceProcess() { return m_SourceProcess.query();}
bool CAddPartToPackageMapRequest::getAllowForeignFiles() { return m_AllowForeignFiles;}
bool CAddPartToPackageMapRequest::getPreloadAllPackages() { return m_PreloadAllPackages;}
bool CAddPartToPackageMapRequest::getUpdateSuperFiles() { return m_UpdateSuperFiles;}
bool CAddPartToPackageMapRequest::getUpdateCloneFrom() { return m_UpdateCloneFrom;}
bool CAddPartToPackageMapRequest::getAppendCluster() { return m_AppendCluster;}
void CAddPartToPackageMapRequest::setTarget(const char * val){ m_Target.set(val); }
void CAddPartToPackageMapRequest::setProcess(const char * val){ m_Process.set(val); }
void CAddPartToPackageMapRequest::setPackageMap(const char * val){ m_PackageMap.set(val); }
void CAddPartToPackageMapRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
void CAddPartToPackageMapRequest::setPartName(const char * val){ m_PartName.set(val); }
void CAddPartToPackageMapRequest::setContent(const char * val){ m_Content.set(val); }
void CAddPartToPackageMapRequest::setDeletePrevious(bool val){ m_DeletePrevious=val; }
void CAddPartToPackageMapRequest::setDaliIp(const char * val){ m_DaliIp.set(val); }
void CAddPartToPackageMapRequest::setSourceProcess(const char * val){ m_SourceProcess.set(val); }
void CAddPartToPackageMapRequest::setAllowForeignFiles(bool val){ m_AllowForeignFiles=val; }
void CAddPartToPackageMapRequest::setPreloadAllPackages(bool val){ m_PreloadAllPackages=val; }
void CAddPartToPackageMapRequest::setUpdateSuperFiles(bool val){ m_UpdateSuperFiles=val; }
void CAddPartToPackageMapRequest::setUpdateCloneFrom(bool val){ m_UpdateCloneFrom=val; }
void CAddPartToPackageMapRequest::setAppendCluster(bool val){ m_AppendCluster=val; }
extern "C"  IEspAddPartToPackageMapRequest *createAddPartToPackageMapRequest(const char *serv){return ((IEspAddPartToPackageMapRequest *)new CAddPartToPackageMapRequest(serv));}
extern "C"  IClientAddPartToPackageMapRequest *createClientAddPartToPackageMapRequest(const char *serv){return ((IClientAddPartToPackageMapRequest *)new CAddPartToPackageMapRequest(serv));}

//=======================================================
// class CAddPartToPackageMapResponse Implementation
//=======================================================

CAddPartToPackageMapResponse::CAddPartToPackageMapResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CAddPartToPackageMapResponse::CAddPartToPackageMapResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapResponse");
}

CAddPartToPackageMapResponse::CAddPartToPackageMapResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CAddPartToPackageMapResponse::CAddPartToPackageMapResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_FilesNotFound(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("AddPartToPackageMapResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CAddPartToPackageMapResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"FilesNotFound\">");
		schema.append("<xsd:complexType><xsd:sequence>");
		schema.append("<xsd:element name=\"File\" type=\"xsd:string\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
		schema.append("</xsd:sequence></xsd:complexType>\n");
		schema.append("</xsd:element>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CAddPartToPackageMapResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CAddPartToPackageMapResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CAddPartToPackageMapResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("FilesNotFound");
	form.appendf("<tr><td><b>FilesNotFound: </b></td><td>");
	form.appendf("<textarea name=\"%s\" cols=\"50\" rows=\"5\"></textarea>", extfix.str());
	form.append("</td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CAddPartToPackageMapResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CAddPartToPackageMapResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_FilesNotFound.marshall(rpc_resp, "FilesNotFound", "File");
	}
}


void CAddPartToPackageMapResponse::copy(CAddPartToPackageMapResponse &from)
{
	m_status.copy(from.m_status);
	m_FilesNotFound.copy(from.m_FilesNotFound);
}


void CAddPartToPackageMapResponse::copy(IConstAddPartToPackageMapResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setFilesNotFound(ifrom.getFilesNotFound());
}


void CAddPartToPackageMapResponse::getAttributes(IProperties &attributes)
{
}


void CAddPartToPackageMapResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_FilesNotFound.toStr(ctx, buffer, "FilesNotFound", "File");
	}
}


void CAddPartToPackageMapResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CAddPartToPackageMapResponse::serializer(IEspContext* ctx, IConstAddPartToPackageMapResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<AddPartToPackageMapResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field FilesNotFound
	{
		StringArray& v = src.getFilesNotFound();
		if (v.length()>0)
			buffer.append("<FilesNotFound>");
		for (size32_t i=0;i<v.length();i++)
			buffer.appendf("<File>%s</File>",v.item(i));
		if (v.length()>0)
			buffer.append("</FilesNotFound>");
	}
	if (keepRootTag)
		buffer.append("</AddPartToPackageMapResponse>");
}

bool CAddPartToPackageMapResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_FilesNotFound.unmarshall(rpc_request, "FilesNotFound", basepath);
	}
	return hasValue;
}

bool CAddPartToPackageMapResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_FilesNotFound.unmarshall(ctx, soapval, "FilesNotFound");
	return hasValue;
}

bool CAddPartToPackageMapResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_FilesNotFound.unmarshall(ctx, params, attachments, "FilesNotFound", basepath);
	return hasValue;
}

IConstBasePackageStatus & CAddPartToPackageMapResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
StringArray & CAddPartToPackageMapResponse::getFilesNotFound() { return (StringArray &) m_FilesNotFound; }
IEspBasePackageStatus & CAddPartToPackageMapResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CAddPartToPackageMapResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CAddPartToPackageMapResponse::setFilesNotFound(StringArray &val){ m_FilesNotFound->kill();  CloneArray(m_FilesNotFound.getValue(), val); }
extern "C"  IEspAddPartToPackageMapResponse *createAddPartToPackageMapResponse(const char *serv){return ((IEspAddPartToPackageMapResponse *)new CAddPartToPackageMapResponse(serv));}
extern "C"  IClientAddPartToPackageMapResponse *createClientAddPartToPackageMapResponse(const char *serv){return ((IClientAddPartToPackageMapResponse *)new CAddPartToPackageMapResponse(serv));}

//=======================================================
// class CRemovePartFromPackageMapRequest Implementation
//=======================================================

CRemovePartFromPackageMapRequest::CRemovePartFromPackageMapRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRemovePartFromPackageMapRequest::CRemovePartFromPackageMapRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapRequest");
}

CRemovePartFromPackageMapRequest::CRemovePartFromPackageMapRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CRemovePartFromPackageMapRequest::CRemovePartFromPackageMapRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRemovePartFromPackageMapRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMap\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PartName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CRemovePartFromPackageMapRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRemovePartFromPackageMapRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CRemovePartFromPackageMapRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMap");
	form.appendf("  <tr><td><b>PackageMap: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PartName");
	form.appendf("  <tr><td><b>PartName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRemovePartFromPackageMapRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRemovePartFromPackageMapRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_PackageMap.marshall(rpc_resp, "PackageMap", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
	m_PartName.marshall(rpc_resp, "PartName", "", "", "");
}


void CRemovePartFromPackageMapRequest::copy(CRemovePartFromPackageMapRequest &from)
{
	m_Target.copy(from.m_Target);
	m_PackageMap.copy(from.m_PackageMap);
	m_GlobalScope.copy(from.m_GlobalScope);
	m_PartName.copy(from.m_PartName);
}


void CRemovePartFromPackageMapRequest::copy(IConstRemovePartFromPackageMapRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setPackageMap(ifrom.getPackageMap());
	setGlobalScope(ifrom.getGlobalScope());
	setPartName(ifrom.getPartName());
}


void CRemovePartFromPackageMapRequest::getAttributes(IProperties &attributes)
{
}


void CRemovePartFromPackageMapRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_PackageMap.toStr(ctx, buffer, "PackageMap", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
	m_PartName.toStr(ctx, buffer, "PartName", "", true, "", "");
}


void CRemovePartFromPackageMapRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRemovePartFromPackageMapRequest::serializer(IEspContext* ctx, IConstRemovePartFromPackageMapRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RemovePartFromPackageMapRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field PackageMap
	{
		const char* s = src.getPackageMap();
		if (s && *s)
		{
			buffer.append("<PackageMap>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMap>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	// field PartName
	{
		const char* s = src.getPartName();
		if (s && *s)
		{
			buffer.append("<PartName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PartName>");
		}
	}
	if (keepRootTag)
		buffer.append("</RemovePartFromPackageMapRequest>");
}

bool CRemovePartFromPackageMapRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(rpc_request, "PackageMap", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	hasValue |= m_PartName.unmarshall(rpc_request, "PartName", basepath);
	return hasValue;
}

bool CRemovePartFromPackageMapRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_PackageMap.unmarshall(ctx, soapval, "PackageMap");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	hasValue |= m_PartName.unmarshall(ctx, soapval, "PartName");
	return hasValue;
}

bool CRemovePartFromPackageMapRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(ctx, params, attachments, "PackageMap", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	hasValue |= m_PartName.unmarshall(ctx, params, attachments, "PartName", basepath);
	return hasValue;
}

const char * CRemovePartFromPackageMapRequest::getTarget() { return m_Target.query();}
const char * CRemovePartFromPackageMapRequest::getPackageMap() { return m_PackageMap.query();}
bool CRemovePartFromPackageMapRequest::getGlobalScope() { return m_GlobalScope;}
const char * CRemovePartFromPackageMapRequest::getPartName() { return m_PartName.query();}
void CRemovePartFromPackageMapRequest::setTarget(const char * val){ m_Target.set(val); }
void CRemovePartFromPackageMapRequest::setPackageMap(const char * val){ m_PackageMap.set(val); }
void CRemovePartFromPackageMapRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
void CRemovePartFromPackageMapRequest::setPartName(const char * val){ m_PartName.set(val); }
extern "C"  IEspRemovePartFromPackageMapRequest *createRemovePartFromPackageMapRequest(const char *serv){return ((IEspRemovePartFromPackageMapRequest *)new CRemovePartFromPackageMapRequest(serv));}
extern "C"  IClientRemovePartFromPackageMapRequest *createClientRemovePartFromPackageMapRequest(const char *serv){return ((IClientRemovePartFromPackageMapRequest *)new CRemovePartFromPackageMapRequest(serv));}

//=======================================================
// class CRemovePartFromPackageMapResponse Implementation
//=======================================================

CRemovePartFromPackageMapResponse::CRemovePartFromPackageMapResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CRemovePartFromPackageMapResponse::CRemovePartFromPackageMapResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapResponse");
}

CRemovePartFromPackageMapResponse::CRemovePartFromPackageMapResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CRemovePartFromPackageMapResponse::CRemovePartFromPackageMapResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("RemovePartFromPackageMapResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CRemovePartFromPackageMapResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CRemovePartFromPackageMapResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CRemovePartFromPackageMapResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CRemovePartFromPackageMapResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CRemovePartFromPackageMapResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CRemovePartFromPackageMapResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
	}
}


void CRemovePartFromPackageMapResponse::copy(CRemovePartFromPackageMapResponse &from)
{
	m_status.copy(from.m_status);
}


void CRemovePartFromPackageMapResponse::copy(IConstRemovePartFromPackageMapResponse &ifrom)
{
	setStatus(ifrom.getStatus());
}


void CRemovePartFromPackageMapResponse::getAttributes(IProperties &attributes)
{
}


void CRemovePartFromPackageMapResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
	}
}


void CRemovePartFromPackageMapResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CRemovePartFromPackageMapResponse::serializer(IEspContext* ctx, IConstRemovePartFromPackageMapResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<RemovePartFromPackageMapResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	if (keepRootTag)
		buffer.append("</RemovePartFromPackageMapResponse>");
}

bool CRemovePartFromPackageMapResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
	}
	return hasValue;
}

bool CRemovePartFromPackageMapResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	return hasValue;
}

bool CRemovePartFromPackageMapResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	return hasValue;
}

IConstBasePackageStatus & CRemovePartFromPackageMapResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
IEspBasePackageStatus & CRemovePartFromPackageMapResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CRemovePartFromPackageMapResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
extern "C"  IEspRemovePartFromPackageMapResponse *createRemovePartFromPackageMapResponse(const char *serv){return ((IEspRemovePartFromPackageMapResponse *)new CRemovePartFromPackageMapResponse(serv));}
extern "C"  IClientRemovePartFromPackageMapResponse *createClientRemovePartFromPackageMapResponse(const char *serv){return ((IClientRemovePartFromPackageMapResponse *)new CRemovePartFromPackageMapResponse(serv));}

//=======================================================
// class CGetPartFromPackageMapRequest Implementation
//=======================================================

CGetPartFromPackageMapRequest::CGetPartFromPackageMapRequest(const char *serviceName, IRpcMessageBinding *init)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPartFromPackageMapRequest::CGetPartFromPackageMapRequest(const char *serviceName, const char *bc)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapRequest");
}

CGetPartFromPackageMapRequest::CGetPartFromPackageMapRequest(const char *serviceName, IRpcMessage* rpcmsg)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPartFromPackageMapRequest::CGetPartFromPackageMapRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_Target(nilIgnore),m_PackageMap(nilIgnore),m_GlobalScope(0, nilIgnore,false),m_PartName(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPartFromPackageMapRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"Target\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PackageMap\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" default=\"false\" name=\"GlobalScope\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"PartName\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetPartFromPackageMapRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPartFromPackageMapRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetPartFromPackageMapRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Target");
	form.appendf("  <tr><td><b>Target: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PackageMap");
	form.appendf("  <tr><td><b>PackageMap: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("GlobalScope");
	
	form.appendf("  <tr><td><b>GlobalScope? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("PartName");
	form.appendf("  <tr><td><b>PartName: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPartFromPackageMapRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPartFromPackageMapRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	m_Target.marshall(rpc_resp, "Target", "", "", "");
	m_PackageMap.marshall(rpc_resp, "PackageMap", "", "", "");
	m_GlobalScope.marshall(rpc_resp, "GlobalScope", "", "", "");
	m_PartName.marshall(rpc_resp, "PartName", "", "", "");
}


void CGetPartFromPackageMapRequest::copy(CGetPartFromPackageMapRequest &from)
{
	m_Target.copy(from.m_Target);
	m_PackageMap.copy(from.m_PackageMap);
	m_GlobalScope.copy(from.m_GlobalScope);
	m_PartName.copy(from.m_PartName);
}


void CGetPartFromPackageMapRequest::copy(IConstGetPartFromPackageMapRequest &ifrom)
{
	setTarget(ifrom.getTarget());
	setPackageMap(ifrom.getPackageMap());
	setGlobalScope(ifrom.getGlobalScope());
	setPartName(ifrom.getPartName());
}


void CGetPartFromPackageMapRequest::getAttributes(IProperties &attributes)
{
}


void CGetPartFromPackageMapRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	m_Target.toStr(ctx, buffer, "Target", "", true, "", "");
	m_PackageMap.toStr(ctx, buffer, "PackageMap", "", true, "", "");
	m_GlobalScope.toStr(ctx, buffer, "GlobalScope", "", true, "", "");
	m_PartName.toStr(ctx, buffer, "PartName", "", true, "", "");
}


void CGetPartFromPackageMapRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPartFromPackageMapRequest::serializer(IEspContext* ctx, IConstGetPartFromPackageMapRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPartFromPackageMapRequest>");
	// field Target
	{
		const char* s = src.getTarget();
		if (s && *s)
		{
			buffer.append("<Target>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Target>");
		}
	}
	// field PackageMap
	{
		const char* s = src.getPackageMap();
		if (s && *s)
		{
			buffer.append("<PackageMap>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PackageMap>");
		}
	}
	// field GlobalScope
	{
		bool b = src.getGlobalScope();
		if (b)
			buffer.appendf("<GlobalScope>1</GlobalScope>");
	}
	// field PartName
	{
		const char* s = src.getPartName();
		if (s && *s)
		{
			buffer.append("<PartName>");
			encodeUtf8XML(s,buffer);
			buffer.append("</PartName>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetPartFromPackageMapRequest>");
}

bool CGetPartFromPackageMapRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(rpc_request, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(rpc_request, "PackageMap", basepath);
	hasValue |= m_GlobalScope.unmarshall(rpc_request, "GlobalScope", basepath);
	hasValue |= m_PartName.unmarshall(rpc_request, "PartName", basepath);
	return hasValue;
}

bool CGetPartFromPackageMapRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, soapval, "Target");
	hasValue |= m_PackageMap.unmarshall(ctx, soapval, "PackageMap");
	hasValue |= m_GlobalScope.unmarshall(ctx, soapval, "GlobalScope");
	hasValue |= m_PartName.unmarshall(ctx, soapval, "PartName");
	return hasValue;
}

bool CGetPartFromPackageMapRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_Target.unmarshall(ctx, params, attachments, "Target", basepath);
	hasValue |= m_PackageMap.unmarshall(ctx, params, attachments, "PackageMap", basepath);
	hasValue |= m_GlobalScope.unmarshall(ctx, params, attachments, "GlobalScope", basepath);
	hasValue |= m_PartName.unmarshall(ctx, params, attachments, "PartName", basepath);
	return hasValue;
}

const char * CGetPartFromPackageMapRequest::getTarget() { return m_Target.query();}
const char * CGetPartFromPackageMapRequest::getPackageMap() { return m_PackageMap.query();}
bool CGetPartFromPackageMapRequest::getGlobalScope() { return m_GlobalScope;}
const char * CGetPartFromPackageMapRequest::getPartName() { return m_PartName.query();}
void CGetPartFromPackageMapRequest::setTarget(const char * val){ m_Target.set(val); }
void CGetPartFromPackageMapRequest::setPackageMap(const char * val){ m_PackageMap.set(val); }
void CGetPartFromPackageMapRequest::setGlobalScope(bool val){ m_GlobalScope=val; }
void CGetPartFromPackageMapRequest::setPartName(const char * val){ m_PartName.set(val); }
extern "C"  IEspGetPartFromPackageMapRequest *createGetPartFromPackageMapRequest(const char *serv){return ((IEspGetPartFromPackageMapRequest *)new CGetPartFromPackageMapRequest(serv));}
extern "C"  IClientGetPartFromPackageMapRequest *createClientGetPartFromPackageMapRequest(const char *serv){return ((IClientGetPartFromPackageMapRequest *)new CGetPartFromPackageMapRequest(serv));}

//=======================================================
// class CGetPartFromPackageMapResponse Implementation
//=======================================================

CGetPartFromPackageMapResponse::CGetPartFromPackageMapResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_status(serviceName, nilIgnore),m_Content(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetPartFromPackageMapResponse::CGetPartFromPackageMapResponse(const char *serviceName, const char *bc)
	: m_status(serviceName, nilIgnore),m_Content(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapResponse");
}

CGetPartFromPackageMapResponse::CGetPartFromPackageMapResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_status(serviceName, nilIgnore),m_Content(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetPartFromPackageMapResponse::CGetPartFromPackageMapResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_status(serviceName, nilIgnore),m_Content(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetPartFromPackageMapResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetPartFromPackageMapResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		schema.append("<xsd:element name=\"Exceptions\" type=\"tns:ArrayOfEspException\" minOccurs=\"0\" maxOccurs=\"1\"/>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"status\" type=\"tns:BasePackageStatus\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"Content\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	if (!(flags & 0x10)  || (flags & 0x100))
	{
		CBasePackageStatus::getXsdDefinition(context, request, schema, added);
	}
	return schema;
}

void CGetPartFromPackageMapResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetPartFromPackageMapResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
	if (!added.getValue("BasePackageStatus"))
	{
		added.setValue("BasePackageStatus",1);
		CBasePackageStatus::getMapInfo(info,added);
	}
}

StringBuffer &CGetPartFromPackageMapResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("status");
	form.append("<tr>").append("<td><b>status: </b></td><td><hr/>");
	CBasePackageStatus::getHtmlForm(context, request, serv, method, form, false, extfix.str());
	form.append("<hr/></td></tr>");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("Content");
	form.appendf("  <tr><td><b>Content: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetPartFromPackageMapResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetPartFromPackageMapResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_status.marshall(rpc_resp, "status", "", "", "");
		m_Content.marshall(rpc_resp, "Content", "", "", "");
	}
}


void CGetPartFromPackageMapResponse::copy(CGetPartFromPackageMapResponse &from)
{
	m_status.copy(from.m_status);
	m_Content.copy(from.m_Content);
}


void CGetPartFromPackageMapResponse::copy(IConstGetPartFromPackageMapResponse &ifrom)
{
	setStatus(ifrom.getStatus());
	setContent(ifrom.getContent());
}


void CGetPartFromPackageMapResponse::getAttributes(IProperties &attributes)
{
}


void CGetPartFromPackageMapResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_status.toStr(ctx, buffer, "status", "", false, "", "");
		m_Content.toStr(ctx, buffer, "Content", "", true, "", "");
	}
}


void CGetPartFromPackageMapResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetPartFromPackageMapResponse::serializer(IEspContext* ctx, IConstGetPartFromPackageMapResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetPartFromPackageMapResponse>");
	// field status
	{
		StringBuffer tmp;
		CBasePackageStatus::serializer(ctx,src.getStatus(), tmp, false);
		if (tmp.length()>0)
			buffer.appendf("<status>%s</status>",tmp.str());
	}
	// field Content
	{
		const char* s = src.getContent();
		if (s && *s)
		{
			buffer.append("<Content>");
			encodeUtf8XML(s,buffer);
			buffer.append("</Content>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetPartFromPackageMapResponse>");
}

bool CGetPartFromPackageMapResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_status.unmarshall(rpc_request, "status", basepath);
		hasValue |= m_Content.unmarshall(rpc_request, "Content", basepath);
	}
	return hasValue;
}

bool CGetPartFromPackageMapResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, soapval, "status");
	hasValue |= m_Content.unmarshall(ctx, soapval, "Content");
	return hasValue;
}

bool CGetPartFromPackageMapResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_status.unmarshall(ctx, params, attachments, "status", basepath);
	hasValue |= m_Content.unmarshall(ctx, params, attachments, "Content", basepath);
	return hasValue;
}

IConstBasePackageStatus & CGetPartFromPackageMapResponse::getStatus() { return (IConstBasePackageStatus &) m_status.getValue();}
const char * CGetPartFromPackageMapResponse::getContent() { return m_Content.query();}
IEspBasePackageStatus & CGetPartFromPackageMapResponse::updateStatus(){ return (IEspBasePackageStatus &) m_status.getValue(); }
void CGetPartFromPackageMapResponse::setStatus(IConstBasePackageStatus &ifrom){ m_status.copy(ifrom); }
void CGetPartFromPackageMapResponse::setContent(const char * val){ m_Content.set(val); }
extern "C"  IEspGetPartFromPackageMapResponse *createGetPartFromPackageMapResponse(const char *serv){return ((IEspGetPartFromPackageMapResponse *)new CGetPartFromPackageMapResponse(serv));}
extern "C"  IClientGetPartFromPackageMapResponse *createClientGetPartFromPackageMapResponse(const char *serv){return ((IClientGetPartFromPackageMapResponse *)new CGetPartFromPackageMapResponse(serv));}

//=======================================================
// class CWsPackageProcessPingRequest Implementation
//=======================================================

CWsPackageProcessPingRequest::CWsPackageProcessPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsPackageProcessPingRequest::CWsPackageProcessPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingRequest");
}

CWsPackageProcessPingRequest::CWsPackageProcessPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsPackageProcessPingRequest::CWsPackageProcessPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsPackageProcessPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsPackageProcessPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsPackageProcessPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsPackageProcessPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsPackageProcessPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsPackageProcessPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CWsPackageProcessPingRequest::copy(CWsPackageProcessPingRequest &from)
{
}


void CWsPackageProcessPingRequest::copy(IConstWsPackageProcessPingRequest &ifrom)
{
}


void CWsPackageProcessPingRequest::getAttributes(IProperties &attributes)
{
}


void CWsPackageProcessPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CWsPackageProcessPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsPackageProcessPingRequest::serializer(IEspContext* ctx, IConstWsPackageProcessPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsPackageProcessPingRequest>");
	if (keepRootTag)
		buffer.append("</WsPackageProcessPingRequest>");
}

bool CWsPackageProcessPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CWsPackageProcessPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsPackageProcessPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsPackageProcessPingRequest *createWsPackageProcessPingRequest(const char *serv){return ((IEspWsPackageProcessPingRequest *)new CWsPackageProcessPingRequest(serv));}
extern "C"  IClientWsPackageProcessPingRequest *createClientWsPackageProcessPingRequest(const char *serv){return ((IClientWsPackageProcessPingRequest *)new CWsPackageProcessPingRequest(serv));}

//=======================================================
// class CWsPackageProcessPingResponse Implementation
//=======================================================

CWsPackageProcessPingResponse::CWsPackageProcessPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CWsPackageProcessPingResponse::CWsPackageProcessPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingResponse");
}

CWsPackageProcessPingResponse::CWsPackageProcessPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CWsPackageProcessPingResponse::CWsPackageProcessPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("WsPackageProcessPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CWsPackageProcessPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CWsPackageProcessPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CWsPackageProcessPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CWsPackageProcessPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CWsPackageProcessPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CWsPackageProcessPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void CWsPackageProcessPingResponse::copy(CWsPackageProcessPingResponse &from)
{
}


void CWsPackageProcessPingResponse::copy(IConstWsPackageProcessPingResponse &ifrom)
{
}


void CWsPackageProcessPingResponse::getAttributes(IProperties &attributes)
{
}


void CWsPackageProcessPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void CWsPackageProcessPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CWsPackageProcessPingResponse::serializer(IEspContext* ctx, IConstWsPackageProcessPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<WsPackageProcessPingResponse>");
	if (keepRootTag)
		buffer.append("</WsPackageProcessPingResponse>");
}

bool CWsPackageProcessPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool CWsPackageProcessPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CWsPackageProcessPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspWsPackageProcessPingResponse *createWsPackageProcessPingResponse(const char *serv){return ((IEspWsPackageProcessPingResponse *)new CWsPackageProcessPingResponse(serv));}
extern "C"  IClientWsPackageProcessPingResponse *createClientWsPackageProcessPingResponse(const char *serv){return ((IClientWsPackageProcessPingResponse *)new CWsPackageProcessPingResponse(serv));}

//=======================================================
// class CWsPackageProcessSoapBinding Implementation
//=======================================================

CWsPackageProcessSoapBinding::CWsPackageProcessSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1.03);
}

CWsPackageProcessSoapBinding::CWsPackageProcessSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1.03);

}

void CWsPackageProcessSoapBinding::init_strings()
{
}

int CWsPackageProcessSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspWsPackageProcess> iserv = (IEspWsPackageProcess*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "ActivatePackage")||!stricmp(thecall->get_name(), "ActivatePackageRequest"))
	{
		Owned<CActivatePackageRequest> esp_request = new CActivatePackageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CActivatePackageResponse> esp_response = new CActivatePackageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Write);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ActivatePackage");
			iserv->onActivatePackage(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "ActivatePackage");
		response->set_name("ActivatePackageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "AddPackage")||!stricmp(thecall->get_name(), "AddPackageRequest"))
	{
		Owned<CAddPackageRequest> esp_request = new CAddPackageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAddPackageResponse> esp_response = new CAddPackageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Write);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "AddPackage");
			iserv->onAddPackage(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "AddPackage");
		response->set_name("AddPackageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "AddPartToPackageMap")||!stricmp(thecall->get_name(), "AddPartToPackageMapRequest"))
	{
		Owned<CAddPartToPackageMapRequest> esp_request = new CAddPartToPackageMapRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CAddPartToPackageMapResponse> esp_response = new CAddPartToPackageMapResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Write);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "AddPartToPackageMap");
			iserv->onAddPartToPackageMap(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "AddPartToPackageMap");
		response->set_name("AddPartToPackageMapResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "CopyPackageMap")||!stricmp(thecall->get_name(), "CopyPackageMapRequest"))
	{
		Owned<CCopyPackageMapRequest> esp_request = new CCopyPackageMapRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CCopyPackageMapResponse> esp_response = new CCopyPackageMapResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Write);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "CopyPackageMap");
			iserv->onCopyPackageMap(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "CopyPackageMap");
		response->set_name("CopyPackageMapResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeActivatePackage")||!stricmp(thecall->get_name(), "DeActivatePackageRequest"))
	{
		Owned<CDeActivatePackageRequest> esp_request = new CDeActivatePackageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeActivatePackageResponse> esp_response = new CDeActivatePackageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Write);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "DeActivatePackage");
			iserv->onDeActivatePackage(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "DeActivatePackage");
		response->set_name("DeActivatePackageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "DeletePackage")||!stricmp(thecall->get_name(), "DeletePackageRequest"))
	{
		Owned<CDeletePackageRequest> esp_request = new CDeletePackageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CDeletePackageResponse> esp_response = new CDeletePackageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Full);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "DeletePackage");
			iserv->onDeletePackage(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "DeletePackage");
		response->set_name("DeletePackageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Echo")||!stricmp(thecall->get_name(), "EchoRequest"))
	{
		Owned<CEchoRequest> esp_request = new CEchoRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CEchoResponse> esp_response = new CEchoResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "Echo");
			iserv->onEcho(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "Echo");
		response->set_name("EchoResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetPackage")||!stricmp(thecall->get_name(), "GetPackageRequest"))
	{
		Owned<CGetPackageRequest> esp_request = new CGetPackageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetPackageResponse> esp_response = new CGetPackageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPackage");
			iserv->onGetPackage(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "GetPackage");
		response->set_name("GetPackageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetPackageMapById")||!stricmp(thecall->get_name(), "GetPackageMapByIdRequest"))
	{
		Owned<CGetPackageMapByIdRequest> esp_request = new CGetPackageMapByIdRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetPackageMapByIdResponse> esp_response = new CGetPackageMapByIdResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPackageMapById");
			iserv->onGetPackageMapById(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "GetPackageMapById");
		response->set_name("GetPackageMapByIdResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetPackageMapSelectOptions")||!stricmp(thecall->get_name(), "GetPackageMapSelectOptionsRequest"))
	{
		Owned<CGetPackageMapSelectOptionsRequest> esp_request = new CGetPackageMapSelectOptionsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetPackageMapSelectOptionsResponse> esp_response = new CGetPackageMapSelectOptionsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPackageMapSelectOptions");
			iserv->onGetPackageMapSelectOptions(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "GetPackageMapSelectOptions");
		response->set_name("GetPackageMapSelectOptionsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetPartFromPackageMap")||!stricmp(thecall->get_name(), "GetPartFromPackageMapRequest"))
	{
		Owned<CGetPartFromPackageMapRequest> esp_request = new CGetPartFromPackageMapRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetPartFromPackageMapResponse> esp_response = new CGetPartFromPackageMapResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPartFromPackageMap");
			iserv->onGetPartFromPackageMap(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "GetPartFromPackageMap");
		response->set_name("GetPartFromPackageMapResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "GetQueryFileMapping")||!stricmp(thecall->get_name(), "GetQueryFileMappingRequest"))
	{
		Owned<CGetQueryFileMappingRequest> esp_request = new CGetQueryFileMappingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetQueryFileMappingResponse> esp_response = new CGetQueryFileMappingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetQueryFileMapping");
			iserv->onGetQueryFileMapping(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "GetQueryFileMapping");
		response->set_name("GetQueryFileMappingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ListPackage")||!stricmp(thecall->get_name(), "ListPackageRequest"))
	{
		Owned<CListPackageRequest> esp_request = new CListPackageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CListPackageResponse> esp_response = new CListPackageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ListPackage");
			iserv->onListPackage(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "ListPackage");
		response->set_name("ListPackageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ListPackages")||!stricmp(thecall->get_name(), "ListPackagesRequest"))
	{
		Owned<CListPackagesRequest> esp_request = new CListPackagesRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CListPackagesResponse> esp_response = new CListPackagesResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ListPackages");
			iserv->onListPackages(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "ListPackages");
		response->set_name("ListPackagesResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "WsPackageProcessPingRequest"))
	{
		Owned<CWsPackageProcessPingRequest> esp_request = new CWsPackageProcessPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CWsPackageProcessPingResponse> esp_response = new CWsPackageProcessPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "Ping");
		response->set_name("WsPackageProcessPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "RemovePartFromPackageMap")||!stricmp(thecall->get_name(), "RemovePartFromPackageMapRequest"))
	{
		Owned<CRemovePartFromPackageMapRequest> esp_request = new CRemovePartFromPackageMapRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CRemovePartFromPackageMapResponse> esp_response = new CRemovePartFromPackageMapResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Write);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "RemovePartFromPackageMap");
			iserv->onRemovePartFromPackageMap(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "RemovePartFromPackageMap");
		response->set_name("RemovePartFromPackageMapResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "ValidatePackage")||!stricmp(thecall->get_name(), "ValidatePackageRequest"))
	{
		Owned<CValidatePackageRequest> esp_request = new CValidatePackageRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CValidatePackageResponse> esp_response = new CValidatePackageResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
		accessmap.setValue("PackageMapAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("WsPackageProcess::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ValidatePackage");
			iserv->onValidatePackage(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "WsPackageProcess", "ValidatePackage");
		response->set_name("ValidatePackageResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int CWsPackageProcessSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.03);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "WsPackageProcess"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ActivatePackage"))) || Utils::strcasecmp(method, "ActivatePackage")==0)
	{
		CActivatePackageRequest::getMapInfo(context.queryMapInfo());
		CActivatePackageResponse::getMapInfo(context.queryMapInfo());
		CActivatePackageRequest::getXsdDefinition(context, request, "ActivatePackageRequest", content, added);
		CActivatePackageResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AddPackage"))) || Utils::strcasecmp(method, "AddPackage")==0)
	{
		CAddPackageRequest::getMapInfo(context.queryMapInfo());
		CAddPackageResponse::getMapInfo(context.queryMapInfo());
		CAddPackageRequest::getXsdDefinition(context, request, "AddPackageRequest", content, added);
		CAddPackageResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "AddPartToPackageMap"))) || Utils::strcasecmp(method, "AddPartToPackageMap")==0)
	{
		CAddPartToPackageMapRequest::getMapInfo(context.queryMapInfo());
		CAddPartToPackageMapResponse::getMapInfo(context.queryMapInfo());
		CAddPartToPackageMapRequest::getXsdDefinition(context, request, "AddPartToPackageMapRequest", content, added);
		CAddPartToPackageMapResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "CopyPackageMap"))) || Utils::strcasecmp(method, "CopyPackageMap")==0)
	{
		CCopyPackageMapRequest::getMapInfo(context.queryMapInfo());
		CCopyPackageMapResponse::getMapInfo(context.queryMapInfo());
		CCopyPackageMapRequest::getXsdDefinition(context, request, "CopyPackageMapRequest", content, added);
		CCopyPackageMapResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeActivatePackage"))) || Utils::strcasecmp(method, "DeActivatePackage")==0)
	{
		CDeActivatePackageRequest::getMapInfo(context.queryMapInfo());
		CDeActivatePackageResponse::getMapInfo(context.queryMapInfo());
		CDeActivatePackageRequest::getXsdDefinition(context, request, "DeActivatePackageRequest", content, added);
		CDeActivatePackageResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "DeletePackage"))) || Utils::strcasecmp(method, "DeletePackage")==0)
	{
		CDeletePackageRequest::getMapInfo(context.queryMapInfo());
		CDeletePackageResponse::getMapInfo(context.queryMapInfo());
		CDeletePackageRequest::getXsdDefinition(context, request, "DeletePackageRequest", content, added);
		CDeletePackageResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Echo"))) || Utils::strcasecmp(method, "Echo")==0)
	{
		CEchoRequest::getMapInfo(context.queryMapInfo());
		CEchoResponse::getMapInfo(context.queryMapInfo());
		CEchoRequest::getXsdDefinition(context, request, "EchoRequest", content, added);
		CEchoResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetPackage"))) || Utils::strcasecmp(method, "GetPackage")==0)
	{
		CGetPackageRequest::getMapInfo(context.queryMapInfo());
		CGetPackageResponse::getMapInfo(context.queryMapInfo());
		CGetPackageRequest::getXsdDefinition(context, request, "GetPackageRequest", content, added);
		CGetPackageResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetPackageMapById"))) || Utils::strcasecmp(method, "GetPackageMapById")==0)
	{
		CGetPackageMapByIdRequest::getMapInfo(context.queryMapInfo());
		CGetPackageMapByIdResponse::getMapInfo(context.queryMapInfo());
		CGetPackageMapByIdRequest::getXsdDefinition(context, request, "GetPackageMapByIdRequest", content, added);
		CGetPackageMapByIdResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetPackageMapSelectOptions"))) || Utils::strcasecmp(method, "GetPackageMapSelectOptions")==0)
	{
		CGetPackageMapSelectOptionsRequest::getMapInfo(context.queryMapInfo());
		CGetPackageMapSelectOptionsResponse::getMapInfo(context.queryMapInfo());
		CGetPackageMapSelectOptionsRequest::getXsdDefinition(context, request, "GetPackageMapSelectOptionsRequest", content, added);
		CGetPackageMapSelectOptionsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetPartFromPackageMap"))) || Utils::strcasecmp(method, "GetPartFromPackageMap")==0)
	{
		CGetPartFromPackageMapRequest::getMapInfo(context.queryMapInfo());
		CGetPartFromPackageMapResponse::getMapInfo(context.queryMapInfo());
		CGetPartFromPackageMapRequest::getXsdDefinition(context, request, "GetPartFromPackageMapRequest", content, added);
		CGetPartFromPackageMapResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetQueryFileMapping"))) || Utils::strcasecmp(method, "GetQueryFileMapping")==0)
	{
		CGetQueryFileMappingRequest::getMapInfo(context.queryMapInfo());
		CGetQueryFileMappingResponse::getMapInfo(context.queryMapInfo());
		CGetQueryFileMappingRequest::getXsdDefinition(context, request, "GetQueryFileMappingRequest", content, added);
		CGetQueryFileMappingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ListPackage"))) || Utils::strcasecmp(method, "ListPackage")==0)
	{
		CListPackageRequest::getMapInfo(context.queryMapInfo());
		CListPackageResponse::getMapInfo(context.queryMapInfo());
		CListPackageRequest::getXsdDefinition(context, request, "ListPackageRequest", content, added);
		CListPackageResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ListPackages"))) || Utils::strcasecmp(method, "ListPackages")==0)
	{
		CListPackagesRequest::getMapInfo(context.queryMapInfo());
		CListPackagesResponse::getMapInfo(context.queryMapInfo());
		CListPackagesRequest::getXsdDefinition(context, request, "ListPackagesRequest", content, added);
		CListPackagesResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		CWsPackageProcessPingRequest::getMapInfo(context.queryMapInfo());
		CWsPackageProcessPingResponse::getMapInfo(context.queryMapInfo());
		CWsPackageProcessPingRequest::getXsdDefinition(context, request, "WsPackageProcessPingRequest", content, added);
		CWsPackageProcessPingResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "RemovePartFromPackageMap"))) || Utils::strcasecmp(method, "RemovePartFromPackageMap")==0)
	{
		CRemovePartFromPackageMapRequest::getMapInfo(context.queryMapInfo());
		CRemovePartFromPackageMapResponse::getMapInfo(context.queryMapInfo());
		CRemovePartFromPackageMapRequest::getXsdDefinition(context, request, "RemovePartFromPackageMapRequest", content, added);
		CRemovePartFromPackageMapResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "ValidatePackage"))) || Utils::strcasecmp(method, "ValidatePackage")==0)
	{
		CValidatePackageRequest::getMapInfo(context.queryMapInfo());
		CValidatePackageResponse::getMapInfo(context.queryMapInfo());
		CValidatePackageRequest::getXsdDefinition(context, request, "ValidatePackageRequest", content, added);
		CValidatePackageResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int CWsPackageProcessSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "ActivatePackage")==0)
	{
		CActivatePackageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "AddPackage")==0)
	{
		CAddPackageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "AddPartToPackageMap")==0)
	{
		CAddPartToPackageMapRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "CopyPackageMap")==0)
	{
		CCopyPackageMapRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeActivatePackage")==0)
	{
		CDeActivatePackageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "DeletePackage")==0)
	{
		CDeletePackageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Echo")==0)
	{
		CEchoRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetPackage")==0)
	{
		CGetPackageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetPackageMapById")==0)
	{
		CGetPackageMapByIdRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetPackageMapSelectOptions")==0)
	{
		CGetPackageMapSelectOptionsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetPartFromPackageMap")==0)
	{
		CGetPartFromPackageMapRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "GetQueryFileMapping")==0)
	{
		CGetQueryFileMappingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ListPackage")==0)
	{
		CListPackageRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ListPackages")==0)
	{
		CListPackagesRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		CWsPackageProcessPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "RemovePartFromPackageMap")==0)
	{
		CRemovePartFromPackageMapRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "ValidatePackage")==0)
	{
		CValidatePackageRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int CWsPackageProcessSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "WsPackageProcess"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ActivatePackage")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ActivatePackage", "ActivatePackageRequest", "ActivatePackageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AddPackage")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("AddPackage", "AddPackageRequest", "AddPackageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "AddPartToPackageMap")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("AddPartToPackageMap", "AddPartToPackageMapRequest", "AddPartToPackageMapResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "CopyPackageMap")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("CopyPackageMap", "CopyPackageMapRequest", "CopyPackageMapResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeActivatePackage")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DeActivatePackage", "DeActivatePackageRequest", "DeActivatePackageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "DeletePackage")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("DeletePackage", "DeletePackageRequest", "DeletePackageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Echo")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Echo", "EchoRequest", "EchoResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetPackage")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetPackage", "GetPackageRequest", "GetPackageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetPackageMapById")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetPackageMapById", "GetPackageMapByIdRequest", "GetPackageMapByIdResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetPackageMapSelectOptions")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetPackageMapSelectOptions", "GetPackageMapSelectOptionsRequest", "GetPackageMapSelectOptionsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetPartFromPackageMap")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetPartFromPackageMap", "GetPartFromPackageMapRequest", "GetPartFromPackageMapResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetQueryFileMapping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetQueryFileMapping", "GetQueryFileMappingRequest", "GetQueryFileMappingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ListPackage")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ListPackage", "ListPackageRequest", "ListPackageResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ListPackages")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ListPackages", "ListPackagesRequest", "ListPackagesResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "WsPackageProcessPingRequest", "WsPackageProcessPingResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "RemovePartFromPackageMap")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("RemovePartFromPackageMap", "RemovePartFromPackageMapRequest", "RemovePartFromPackageMapResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "ValidatePackage")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("ValidatePackage", "ValidatePackageRequest", "ValidatePackageResponse"));
	return methods.ordinality();
}

StringBuffer & CWsPackageProcessSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("WsPackageProcess");
	return resp;
}

bool CWsPackageProcessSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "WsPackageProcess"))
		return true;
	else
		return (hasSubService(context, name));
}

bool CWsPackageProcessSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "ActivatePackage")==0)
	{
		if (methQName!=NULL)
			methQName->set("ActivatePackage");
		return true;
	}
	if (Utils::strcasecmp(methname, "AddPackage")==0)
	{
		if (methQName!=NULL)
			methQName->set("AddPackage");
		return true;
	}
	if (Utils::strcasecmp(methname, "AddPartToPackageMap")==0)
	{
		if (methQName!=NULL)
			methQName->set("AddPartToPackageMap");
		return true;
	}
	if (Utils::strcasecmp(methname, "CopyPackageMap")==0)
	{
		if (methQName!=NULL)
			methQName->set("CopyPackageMap");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeActivatePackage")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeActivatePackage");
		return true;
	}
	if (Utils::strcasecmp(methname, "DeletePackage")==0)
	{
		if (methQName!=NULL)
			methQName->set("DeletePackage");
		return true;
	}
	if (Utils::strcasecmp(methname, "Echo")==0)
	{
		if (methQName!=NULL)
			methQName->set("Echo");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetPackage")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetPackage");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetPackageMapById")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetPackageMapById");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetPackageMapSelectOptions")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetPackageMapSelectOptions");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetPartFromPackageMap")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetPartFromPackageMap");
		return true;
	}
	if (Utils::strcasecmp(methname, "GetQueryFileMapping")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetQueryFileMapping");
		return true;
	}
	if (Utils::strcasecmp(methname, "ListPackage")==0)
	{
		if (methQName!=NULL)
			methQName->set("ListPackage");
		return true;
	}
	if (Utils::strcasecmp(methname, "ListPackages")==0)
	{
		if (methQName!=NULL)
			methQName->set("ListPackages");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	if (Utils::strcasecmp(methname, "RemovePartFromPackageMap")==0)
	{
		if (methQName!=NULL)
			methQName->set("RemovePartFromPackageMap");
		return true;
	}
	if (Utils::strcasecmp(methname, "ValidatePackage")==0)
	{
		if (methQName!=NULL)
			methQName->set("ValidatePackage");
		return true;
	}
	return false;
}

bool CWsPackageProcessSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "WsPackageProcess"))
	{
		servQName.append("WsPackageProcess");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int CWsPackageProcessSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int CWsPackageProcessSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.03);

	if (!stricmp("ActivatePackage", method)) {
		CActivatePackageRequest::getMapInfo(context.queryMapInfo());
		CActivatePackageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("AddPackage", method)) {
		CAddPackageRequest::getMapInfo(context.queryMapInfo());
		CAddPackageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("AddPartToPackageMap", method)) {
		CAddPartToPackageMapRequest::getMapInfo(context.queryMapInfo());
		CAddPartToPackageMapResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("CopyPackageMap", method)) {
		CCopyPackageMapRequest::getMapInfo(context.queryMapInfo());
		CCopyPackageMapResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeActivatePackage", method)) {
		CDeActivatePackageRequest::getMapInfo(context.queryMapInfo());
		CDeActivatePackageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("DeletePackage", method)) {
		CDeletePackageRequest::getMapInfo(context.queryMapInfo());
		CDeletePackageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Echo", method)) {
		CEchoRequest::getMapInfo(context.queryMapInfo());
		CEchoResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetPackage", method)) {
		CGetPackageRequest::getMapInfo(context.queryMapInfo());
		CGetPackageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetPackageMapById", method)) {
		CGetPackageMapByIdRequest::getMapInfo(context.queryMapInfo());
		CGetPackageMapByIdResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetPackageMapSelectOptions", method)) {
		CGetPackageMapSelectOptionsRequest::getMapInfo(context.queryMapInfo());
		CGetPackageMapSelectOptionsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetPartFromPackageMap", method)) {
		CGetPartFromPackageMapRequest::getMapInfo(context.queryMapInfo());
		CGetPartFromPackageMapResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("GetQueryFileMapping", method)) {
		CGetQueryFileMappingRequest::getMapInfo(context.queryMapInfo());
		CGetQueryFileMappingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ListPackage", method)) {
		CListPackageRequest::getMapInfo(context.queryMapInfo());
		CListPackageResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ListPackages", method)) {
		CListPackagesRequest::getMapInfo(context.queryMapInfo());
		CListPackagesResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		CWsPackageProcessPingRequest::getMapInfo(context.queryMapInfo());
		CWsPackageProcessPingResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("RemovePartFromPackageMap", method)) {
		CRemovePartFromPackageMapRequest::getMapInfo(context.queryMapInfo());
		CRemovePartFromPackageMapResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("ValidatePackage", method)) {
		CValidatePackageRequest::getMapInfo(context.queryMapInfo());
		CValidatePackageResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int CWsPackageProcessSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int CWsPackageProcessSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *CWsPackageProcessSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "ActivatePackage") || !stricmp(method, "ActivatePackageRequest"))
		return new CActivatePackageRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "AddPackage") || !stricmp(method, "AddPackageRequest"))
		return new CAddPackageRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "AddPartToPackageMap") || !stricmp(method, "AddPartToPackageMapRequest"))
		return new CAddPartToPackageMapRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "CopyPackageMap") || !stricmp(method, "CopyPackageMapRequest"))
		return new CCopyPackageMapRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "DeActivatePackage") || !stricmp(method, "DeActivatePackageRequest"))
		return new CDeActivatePackageRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "DeletePackage") || !stricmp(method, "DeletePackageRequest"))
		return new CDeletePackageRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "Echo") || !stricmp(method, "EchoRequest"))
		return new CEchoRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "GetPackage") || !stricmp(method, "GetPackageRequest"))
		return new CGetPackageRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "GetPackageMapById") || !stricmp(method, "GetPackageMapByIdRequest"))
		return new CGetPackageMapByIdRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "GetPackageMapSelectOptions") || !stricmp(method, "GetPackageMapSelectOptionsRequest"))
		return new CGetPackageMapSelectOptionsRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "GetPartFromPackageMap") || !stricmp(method, "GetPartFromPackageMapRequest"))
		return new CGetPartFromPackageMapRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "GetQueryFileMapping") || !stricmp(method, "GetQueryFileMappingRequest"))
		return new CGetQueryFileMappingRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "ListPackage") || !stricmp(method, "ListPackageRequest"))
		return new CListPackageRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "ListPackages") || !stricmp(method, "ListPackagesRequest"))
		return new CListPackagesRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "WsPackageProcessPingRequest"))
		return new CWsPackageProcessPingRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "RemovePartFromPackageMap") || !stricmp(method, "RemovePartFromPackageMapRequest"))
		return new CRemovePartFromPackageMapRequest(&context, "WsPackageProcess", props, NULL);
	if (!stricmp(method, "ValidatePackage") || !stricmp(method, "ValidatePackageRequest"))
		return new CValidatePackageRequest(&context, "WsPackageProcess", props, NULL);
	return NULL;
}

int CWsPackageProcessSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1.03);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspWsPackageProcess> iserv = (IEspWsPackageProcess*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "ActivatePackage")||!stricmp(method, "ActivatePackageRequest"))
		{
			Owned<CActivatePackageRequest> esp_request = new CActivatePackageRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CActivatePackageResponse* resp = new CActivatePackageResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Write);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ActivatePackage");
				iserv->onActivatePackage(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "ActivatePackage", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "AddPackage")||!stricmp(method, "AddPackageRequest"))
		{
			Owned<CAddPackageRequest> esp_request = new CAddPackageRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CAddPackageResponse* resp = new CAddPackageResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Write);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "AddPackage");
				iserv->onAddPackage(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "AddPackage", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "AddPartToPackageMap")||!stricmp(method, "AddPartToPackageMapRequest"))
		{
			Owned<CAddPartToPackageMapRequest> esp_request = new CAddPartToPackageMapRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CAddPartToPackageMapResponse* resp = new CAddPartToPackageMapResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Write);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "AddPartToPackageMap");
				iserv->onAddPartToPackageMap(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "AddPartToPackageMap", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "CopyPackageMap")||!stricmp(method, "CopyPackageMapRequest"))
		{
			Owned<CCopyPackageMapRequest> esp_request = new CCopyPackageMapRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CCopyPackageMapResponse* resp = new CCopyPackageMapResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Write);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "CopyPackageMap");
				iserv->onCopyPackageMap(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "CopyPackageMap", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DeActivatePackage")||!stricmp(method, "DeActivatePackageRequest"))
		{
			Owned<CDeActivatePackageRequest> esp_request = new CDeActivatePackageRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeActivatePackageResponse* resp = new CDeActivatePackageResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Write);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "DeActivatePackage");
				iserv->onDeActivatePackage(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "DeActivatePackage", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "DeletePackage")||!stricmp(method, "DeletePackageRequest"))
		{
			Owned<CDeletePackageRequest> esp_request = new CDeletePackageRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CDeletePackageResponse* resp = new CDeletePackageResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Full);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "DeletePackage");
				iserv->onDeletePackage(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "DeletePackage", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Echo")||!stricmp(method, "EchoRequest"))
		{
			Owned<CEchoRequest> esp_request = new CEchoRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CEchoResponse* resp = new CEchoResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "Echo");
				iserv->onEcho(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "Echo", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetPackage")||!stricmp(method, "GetPackageRequest"))
		{
			Owned<CGetPackageRequest> esp_request = new CGetPackageRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetPackageResponse* resp = new CGetPackageResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPackage");
				iserv->onGetPackage(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "GetPackage", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetPackageMapById")||!stricmp(method, "GetPackageMapByIdRequest"))
		{
			Owned<CGetPackageMapByIdRequest> esp_request = new CGetPackageMapByIdRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetPackageMapByIdResponse* resp = new CGetPackageMapByIdResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPackageMapById");
				iserv->onGetPackageMapById(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "GetPackageMapById", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetPackageMapSelectOptions")||!stricmp(method, "GetPackageMapSelectOptionsRequest"))
		{
			Owned<CGetPackageMapSelectOptionsRequest> esp_request = new CGetPackageMapSelectOptionsRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetPackageMapSelectOptionsResponse* resp = new CGetPackageMapSelectOptionsResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPackageMapSelectOptions");
				iserv->onGetPackageMapSelectOptions(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "GetPackageMapSelectOptions", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetPartFromPackageMap")||!stricmp(method, "GetPartFromPackageMapRequest"))
		{
			Owned<CGetPartFromPackageMapRequest> esp_request = new CGetPartFromPackageMapRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetPartFromPackageMapResponse* resp = new CGetPartFromPackageMapResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetPartFromPackageMap");
				iserv->onGetPartFromPackageMap(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "GetPartFromPackageMap", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "GetQueryFileMapping")||!stricmp(method, "GetQueryFileMappingRequest"))
		{
			Owned<CGetQueryFileMappingRequest> esp_request = new CGetQueryFileMappingRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetQueryFileMappingResponse* resp = new CGetQueryFileMappingResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "GetQueryFileMapping");
				iserv->onGetQueryFileMapping(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "GetQueryFileMapping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ListPackage")||!stricmp(method, "ListPackageRequest"))
		{
			Owned<CListPackageRequest> esp_request = new CListPackageRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CListPackageResponse* resp = new CListPackageResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ListPackage");
				iserv->onListPackage(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "ListPackage", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ListPackages")||!stricmp(method, "ListPackagesRequest"))
		{
			Owned<CListPackagesRequest> esp_request = new CListPackagesRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CListPackagesResponse* resp = new CListPackagesResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ListPackages");
				iserv->onListPackages(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "ListPackages", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "WsPackageProcessPingRequest"))
		{
			Owned<CWsPackageProcessPingRequest> esp_request = new CWsPackageProcessPingRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CWsPackageProcessPingResponse* resp = new CWsPackageProcessPingResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "Ping", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "RemovePartFromPackageMap")||!stricmp(method, "RemovePartFromPackageMapRequest"))
		{
			Owned<CRemovePartFromPackageMapRequest> esp_request = new CRemovePartFromPackageMapRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CRemovePartFromPackageMapResponse* resp = new CRemovePartFromPackageMapResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Write);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "RemovePartFromPackageMap");
				iserv->onRemovePartFromPackageMap(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "RemovePartFromPackageMap", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "ValidatePackage")||!stricmp(method, "ValidatePackageRequest"))
		{
			Owned<CValidatePackageRequest> esp_request = new CValidatePackageRequest(&context, "WsPackageProcess", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CValidatePackageResponse* resp = new CValidatePackageResponse("WsPackageProcess");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;

//WARNING: Developer has suppressed automatic feature level authorization, ensure this behavior is correct!
			accessmap.setValue("PackageMapAccess", SecAccess_Read);
			source.setf("WsPackageProcess::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "WsPackageProcess", "ValidatePackage");
				iserv->onValidatePackage(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "WsPackageProcess", "ValidatePackage", StringBuffer(getCFD()).append("./smc_xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method ActivatePackage ---------

IClientActivatePackageRequest * CClientWsPackageProcess::createActivatePackageRequest()
{
	CActivatePackageRequest* request = new CActivatePackageRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientActivatePackageResponse * CClientWsPackageProcess::ActivatePackage(IClientActivatePackageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CActivatePackageRequest* esprequest = static_cast<CActivatePackageRequest*>(request);
	CActivatePackageResponse* espresponse = new CActivatePackageResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_ActivatePackage(IClientActivatePackageRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CActivatePackageRequest* esprequest = static_cast<CActivatePackageRequest*>(request);
	esprequest->setMethod("ActivatePackage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientActivatePackageResponse *CClientWsPackageProcess::ActivatePackageFn(const char * Target_, const char * PackageMap_, const char * Process_, bool GlobalScope_)
{
	Owned<IClientActivatePackageRequest> req =  createActivatePackageRequest();
	req->setTarget(Target_);
	req->setPackageMap(PackageMap_);
	req->setProcess(Process_);
	req->setGlobalScope(GlobalScope_);
	return ActivatePackage(req.get());
}

//------ method AddPackage ---------

IClientAddPackageRequest * CClientWsPackageProcess::createAddPackageRequest()
{
	CAddPackageRequest* request = new CAddPackageRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAddPackageResponse * CClientWsPackageProcess::AddPackage(IClientAddPackageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddPackageRequest* esprequest = static_cast<CAddPackageRequest*>(request);
	CAddPackageResponse* espresponse = new CAddPackageResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_AddPackage(IClientAddPackageRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddPackageRequest* esprequest = static_cast<CAddPackageRequest*>(request);
	esprequest->setMethod("AddPackage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAddPackageResponse *CClientWsPackageProcess::AddPackageFn(const char * Info_, bool Activate_, bool OverWrite_, const char * Target_, const char * PackageMap_, const char * Process_, const char * DaliIp_, bool GlobalScope_, const char * SourceProcess_, bool AllowForeignFiles_, bool PreloadAllPackages_, bool ReplacePackageMap_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_)
{
	Owned<IClientAddPackageRequest> req =  createAddPackageRequest();
	req->setInfo(Info_);
	req->setActivate(Activate_);
	req->setOverWrite(OverWrite_);
	req->setTarget(Target_);
	req->setPackageMap(PackageMap_);
	req->setProcess(Process_);
	req->setDaliIp(DaliIp_);
	req->setGlobalScope(GlobalScope_);
	req->setSourceProcess(SourceProcess_);
	req->setAllowForeignFiles(AllowForeignFiles_);
	req->setPreloadAllPackages(PreloadAllPackages_);
	req->setReplacePackageMap(ReplacePackageMap_);
	req->setUpdateSuperFiles(UpdateSuperFiles_);
	req->setUpdateCloneFrom(UpdateCloneFrom_);
	req->setAppendCluster(AppendCluster_);
	return AddPackage(req.get());
}

//------ method AddPartToPackageMap ---------

IClientAddPartToPackageMapRequest * CClientWsPackageProcess::createAddPartToPackageMapRequest()
{
	CAddPartToPackageMapRequest* request = new CAddPartToPackageMapRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientAddPartToPackageMapResponse * CClientWsPackageProcess::AddPartToPackageMap(IClientAddPartToPackageMapRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddPartToPackageMapRequest* esprequest = static_cast<CAddPartToPackageMapRequest*>(request);
	CAddPartToPackageMapResponse* espresponse = new CAddPartToPackageMapResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_AddPartToPackageMap(IClientAddPartToPackageMapRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CAddPartToPackageMapRequest* esprequest = static_cast<CAddPartToPackageMapRequest*>(request);
	esprequest->setMethod("AddPartToPackageMap");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientAddPartToPackageMapResponse *CClientWsPackageProcess::AddPartToPackageMapFn(const char * Target_, const char * Process_, const char * PackageMap_, bool GlobalScope_, const char * PartName_, const char * Content_, bool DeletePrevious_, const char * DaliIp_, const char * SourceProcess_, bool AllowForeignFiles_, bool PreloadAllPackages_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_)
{
	Owned<IClientAddPartToPackageMapRequest> req =  createAddPartToPackageMapRequest();
	req->setTarget(Target_);
	req->setProcess(Process_);
	req->setPackageMap(PackageMap_);
	req->setGlobalScope(GlobalScope_);
	req->setPartName(PartName_);
	req->setContent(Content_);
	req->setDeletePrevious(DeletePrevious_);
	req->setDaliIp(DaliIp_);
	req->setSourceProcess(SourceProcess_);
	req->setAllowForeignFiles(AllowForeignFiles_);
	req->setPreloadAllPackages(PreloadAllPackages_);
	req->setUpdateSuperFiles(UpdateSuperFiles_);
	req->setUpdateCloneFrom(UpdateCloneFrom_);
	req->setAppendCluster(AppendCluster_);
	return AddPartToPackageMap(req.get());
}

//------ method CopyPackageMap ---------

IClientCopyPackageMapRequest * CClientWsPackageProcess::createCopyPackageMapRequest()
{
	CCopyPackageMapRequest* request = new CCopyPackageMapRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientCopyPackageMapResponse * CClientWsPackageProcess::CopyPackageMap(IClientCopyPackageMapRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCopyPackageMapRequest* esprequest = static_cast<CCopyPackageMapRequest*>(request);
	CCopyPackageMapResponse* espresponse = new CCopyPackageMapResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_CopyPackageMap(IClientCopyPackageMapRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CCopyPackageMapRequest* esprequest = static_cast<CCopyPackageMapRequest*>(request);
	esprequest->setMethod("CopyPackageMap");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientCopyPackageMapResponse *CClientWsPackageProcess::CopyPackageMapFn(const char * SourcePath_, const char * RemoteUserName_, const char * RemotePassword_, const char * Target_, const char * Process_, const char * PMID_, bool Activate_, const char * DaliIp_, bool GlobalScope_, const char * SourceProcess_, bool PreloadAllPackages_, bool ReplacePackageMap_, bool UpdateSuperFiles_, bool UpdateCloneFrom_, bool AppendCluster_)
{
	Owned<IClientCopyPackageMapRequest> req =  createCopyPackageMapRequest();
	req->setSourcePath(SourcePath_);
	req->setRemoteUserName(RemoteUserName_);
	req->setRemotePassword(RemotePassword_);
	req->setTarget(Target_);
	req->setProcess(Process_);
	req->setPMID(PMID_);
	req->setActivate(Activate_);
	req->setDaliIp(DaliIp_);
	req->setGlobalScope(GlobalScope_);
	req->setSourceProcess(SourceProcess_);
	req->setPreloadAllPackages(PreloadAllPackages_);
	req->setReplacePackageMap(ReplacePackageMap_);
	req->setUpdateSuperFiles(UpdateSuperFiles_);
	req->setUpdateCloneFrom(UpdateCloneFrom_);
	req->setAppendCluster(AppendCluster_);
	return CopyPackageMap(req.get());
}

//------ method DeActivatePackage ---------

IClientDeActivatePackageRequest * CClientWsPackageProcess::createDeActivatePackageRequest()
{
	CDeActivatePackageRequest* request = new CDeActivatePackageRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeActivatePackageResponse * CClientWsPackageProcess::DeActivatePackage(IClientDeActivatePackageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeActivatePackageRequest* esprequest = static_cast<CDeActivatePackageRequest*>(request);
	CDeActivatePackageResponse* espresponse = new CDeActivatePackageResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_DeActivatePackage(IClientDeActivatePackageRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeActivatePackageRequest* esprequest = static_cast<CDeActivatePackageRequest*>(request);
	esprequest->setMethod("DeActivatePackage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeActivatePackageResponse *CClientWsPackageProcess::DeActivatePackageFn(const char * Target_, const char * PackageMap_, const char * Process_, bool GlobalScope_)
{
	Owned<IClientDeActivatePackageRequest> req =  createDeActivatePackageRequest();
	req->setTarget(Target_);
	req->setPackageMap(PackageMap_);
	req->setProcess(Process_);
	req->setGlobalScope(GlobalScope_);
	return DeActivatePackage(req.get());
}

//------ method DeletePackage ---------

IClientDeletePackageRequest * CClientWsPackageProcess::createDeletePackageRequest()
{
	CDeletePackageRequest* request = new CDeletePackageRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientDeletePackageResponse * CClientWsPackageProcess::DeletePackage(IClientDeletePackageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeletePackageRequest* esprequest = static_cast<CDeletePackageRequest*>(request);
	CDeletePackageResponse* espresponse = new CDeletePackageResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_DeletePackage(IClientDeletePackageRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CDeletePackageRequest* esprequest = static_cast<CDeletePackageRequest*>(request);
	esprequest->setMethod("DeletePackage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientDeletePackageResponse *CClientWsPackageProcess::DeletePackageFn(const char * Target_, const char * PackageMap_, const char * Process_, bool GlobalScope_, IArrayOf<IConstPackageMapEntry> &PackageMaps_)
{
	Owned<IClientDeletePackageRequest> req =  createDeletePackageRequest();
	req->setTarget(Target_);
	req->setPackageMap(PackageMap_);
	req->setProcess(Process_);
	req->setGlobalScope(GlobalScope_);
	req->setPackageMaps(PackageMaps_);
	return DeletePackage(req.get());
}

//------ method Echo ---------

IClientEchoRequest * CClientWsPackageProcess::createEchoRequest()
{
	CEchoRequest* request = new CEchoRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientEchoResponse * CClientWsPackageProcess::Echo(IClientEchoRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEchoRequest* esprequest = static_cast<CEchoRequest*>(request);
	CEchoResponse* espresponse = new CEchoResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_Echo(IClientEchoRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CEchoRequest* esprequest = static_cast<CEchoRequest*>(request);
	esprequest->setMethod("Echo");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientEchoResponse *CClientWsPackageProcess::EchoFn(const char * Request_)
{
	Owned<IClientEchoRequest> req =  createEchoRequest();
	req->setRequest(Request_);
	return Echo(req.get());
}

//------ method GetPackage ---------

IClientGetPackageRequest * CClientWsPackageProcess::createGetPackageRequest()
{
	CGetPackageRequest* request = new CGetPackageRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetPackageResponse * CClientWsPackageProcess::GetPackage(IClientGetPackageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPackageRequest* esprequest = static_cast<CGetPackageRequest*>(request);
	CGetPackageResponse* espresponse = new CGetPackageResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_GetPackage(IClientGetPackageRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPackageRequest* esprequest = static_cast<CGetPackageRequest*>(request);
	esprequest->setMethod("GetPackage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetPackageResponse *CClientWsPackageProcess::GetPackageFn(const char * Target_, const char * Process_)
{
	Owned<IClientGetPackageRequest> req =  createGetPackageRequest();
	req->setTarget(Target_);
	req->setProcess(Process_);
	return GetPackage(req.get());
}

//------ method GetPackageMapById ---------

IClientGetPackageMapByIdRequest * CClientWsPackageProcess::createGetPackageMapByIdRequest()
{
	CGetPackageMapByIdRequest* request = new CGetPackageMapByIdRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetPackageMapByIdResponse * CClientWsPackageProcess::GetPackageMapById(IClientGetPackageMapByIdRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPackageMapByIdRequest* esprequest = static_cast<CGetPackageMapByIdRequest*>(request);
	CGetPackageMapByIdResponse* espresponse = new CGetPackageMapByIdResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_GetPackageMapById(IClientGetPackageMapByIdRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPackageMapByIdRequest* esprequest = static_cast<CGetPackageMapByIdRequest*>(request);
	esprequest->setMethod("GetPackageMapById");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetPackageMapByIdResponse *CClientWsPackageProcess::GetPackageMapByIdFn(const char * PackageMapId_)
{
	Owned<IClientGetPackageMapByIdRequest> req =  createGetPackageMapByIdRequest();
	req->setPackageMapId(PackageMapId_);
	return GetPackageMapById(req.get());
}

//------ method GetPackageMapSelectOptions ---------

IClientGetPackageMapSelectOptionsRequest * CClientWsPackageProcess::createGetPackageMapSelectOptionsRequest()
{
	CGetPackageMapSelectOptionsRequest* request = new CGetPackageMapSelectOptionsRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetPackageMapSelectOptionsResponse * CClientWsPackageProcess::GetPackageMapSelectOptions(IClientGetPackageMapSelectOptionsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPackageMapSelectOptionsRequest* esprequest = static_cast<CGetPackageMapSelectOptionsRequest*>(request);
	CGetPackageMapSelectOptionsResponse* espresponse = new CGetPackageMapSelectOptionsResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_GetPackageMapSelectOptions(IClientGetPackageMapSelectOptionsRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPackageMapSelectOptionsRequest* esprequest = static_cast<CGetPackageMapSelectOptionsRequest*>(request);
	esprequest->setMethod("GetPackageMapSelectOptions");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetPackageMapSelectOptionsResponse *CClientWsPackageProcess::GetPackageMapSelectOptionsFn(bool IncludeTargets_, bool IncludeProcesses_, bool IncludeProcessFilters_)
{
	Owned<IClientGetPackageMapSelectOptionsRequest> req =  createGetPackageMapSelectOptionsRequest();
	req->setIncludeTargets(IncludeTargets_);
	req->setIncludeProcesses(IncludeProcesses_);
	req->setIncludeProcessFilters(IncludeProcessFilters_);
	return GetPackageMapSelectOptions(req.get());
}

//------ method GetPartFromPackageMap ---------

IClientGetPartFromPackageMapRequest * CClientWsPackageProcess::createGetPartFromPackageMapRequest()
{
	CGetPartFromPackageMapRequest* request = new CGetPartFromPackageMapRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetPartFromPackageMapResponse * CClientWsPackageProcess::GetPartFromPackageMap(IClientGetPartFromPackageMapRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPartFromPackageMapRequest* esprequest = static_cast<CGetPartFromPackageMapRequest*>(request);
	CGetPartFromPackageMapResponse* espresponse = new CGetPartFromPackageMapResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_GetPartFromPackageMap(IClientGetPartFromPackageMapRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetPartFromPackageMapRequest* esprequest = static_cast<CGetPartFromPackageMapRequest*>(request);
	esprequest->setMethod("GetPartFromPackageMap");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetPartFromPackageMapResponse *CClientWsPackageProcess::GetPartFromPackageMapFn(const char * Target_, const char * PackageMap_, bool GlobalScope_, const char * PartName_)
{
	Owned<IClientGetPartFromPackageMapRequest> req =  createGetPartFromPackageMapRequest();
	req->setTarget(Target_);
	req->setPackageMap(PackageMap_);
	req->setGlobalScope(GlobalScope_);
	req->setPartName(PartName_);
	return GetPartFromPackageMap(req.get());
}

//------ method GetQueryFileMapping ---------

IClientGetQueryFileMappingRequest * CClientWsPackageProcess::createGetQueryFileMappingRequest()
{
	CGetQueryFileMappingRequest* request = new CGetQueryFileMappingRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetQueryFileMappingResponse * CClientWsPackageProcess::GetQueryFileMapping(IClientGetQueryFileMappingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetQueryFileMappingRequest* esprequest = static_cast<CGetQueryFileMappingRequest*>(request);
	CGetQueryFileMappingResponse* espresponse = new CGetQueryFileMappingResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_GetQueryFileMapping(IClientGetQueryFileMappingRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetQueryFileMappingRequest* esprequest = static_cast<CGetQueryFileMappingRequest*>(request);
	esprequest->setMethod("GetQueryFileMapping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetQueryFileMappingResponse *CClientWsPackageProcess::GetQueryFileMappingFn(const char * Target_, const char * PMID_, const char * QueryName_, bool GlobalScope_)
{
	Owned<IClientGetQueryFileMappingRequest> req =  createGetQueryFileMappingRequest();
	req->setTarget(Target_);
	req->setPMID(PMID_);
	req->setQueryName(QueryName_);
	req->setGlobalScope(GlobalScope_);
	return GetQueryFileMapping(req.get());
}

//------ method ListPackage ---------

IClientListPackageRequest * CClientWsPackageProcess::createListPackageRequest()
{
	CListPackageRequest* request = new CListPackageRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientListPackageResponse * CClientWsPackageProcess::ListPackage(IClientListPackageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListPackageRequest* esprequest = static_cast<CListPackageRequest*>(request);
	CListPackageResponse* espresponse = new CListPackageResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_ListPackage(IClientListPackageRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListPackageRequest* esprequest = static_cast<CListPackageRequest*>(request);
	esprequest->setMethod("ListPackage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientListPackageResponse *CClientWsPackageProcess::ListPackageFn(const char * Target_, const char * Process_)
{
	Owned<IClientListPackageRequest> req =  createListPackageRequest();
	req->setTarget(Target_);
	req->setProcess(Process_);
	return ListPackage(req.get());
}

//------ method ListPackages ---------

IClientListPackagesRequest * CClientWsPackageProcess::createListPackagesRequest()
{
	CListPackagesRequest* request = new CListPackagesRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientListPackagesResponse * CClientWsPackageProcess::ListPackages(IClientListPackagesRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListPackagesRequest* esprequest = static_cast<CListPackagesRequest*>(request);
	CListPackagesResponse* espresponse = new CListPackagesResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_ListPackages(IClientListPackagesRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CListPackagesRequest* esprequest = static_cast<CListPackagesRequest*>(request);
	esprequest->setMethod("ListPackages");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientListPackagesResponse *CClientWsPackageProcess::ListPackagesFn(const char * Target_, const char * Process_, const char * ProcessFilter_)
{
	Owned<IClientListPackagesRequest> req =  createListPackagesRequest();
	req->setTarget(Target_);
	req->setProcess(Process_);
	req->setProcessFilter(ProcessFilter_);
	return ListPackages(req.get());
}

//------ method Ping ---------

IClientWsPackageProcessPingRequest * CClientWsPackageProcess::createPingRequest()
{
	CWsPackageProcessPingRequest* request = new CWsPackageProcessPingRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientWsPackageProcessPingResponse * CClientWsPackageProcess::Ping(IClientWsPackageProcessPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsPackageProcessPingRequest* esprequest = static_cast<CWsPackageProcessPingRequest*>(request);
	CWsPackageProcessPingResponse* espresponse = new CWsPackageProcessPingResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_Ping(IClientWsPackageProcessPingRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CWsPackageProcessPingRequest* esprequest = static_cast<CWsPackageProcessPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientWsPackageProcessPingResponse *CClientWsPackageProcess::PingFn()
{
	Owned<IClientWsPackageProcessPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

//------ method RemovePartFromPackageMap ---------

IClientRemovePartFromPackageMapRequest * CClientWsPackageProcess::createRemovePartFromPackageMapRequest()
{
	CRemovePartFromPackageMapRequest* request = new CRemovePartFromPackageMapRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientRemovePartFromPackageMapResponse * CClientWsPackageProcess::RemovePartFromPackageMap(IClientRemovePartFromPackageMapRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRemovePartFromPackageMapRequest* esprequest = static_cast<CRemovePartFromPackageMapRequest*>(request);
	CRemovePartFromPackageMapResponse* espresponse = new CRemovePartFromPackageMapResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_RemovePartFromPackageMap(IClientRemovePartFromPackageMapRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CRemovePartFromPackageMapRequest* esprequest = static_cast<CRemovePartFromPackageMapRequest*>(request);
	esprequest->setMethod("RemovePartFromPackageMap");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientRemovePartFromPackageMapResponse *CClientWsPackageProcess::RemovePartFromPackageMapFn(const char * Target_, const char * PackageMap_, bool GlobalScope_, const char * PartName_)
{
	Owned<IClientRemovePartFromPackageMapRequest> req =  createRemovePartFromPackageMapRequest();
	req->setTarget(Target_);
	req->setPackageMap(PackageMap_);
	req->setGlobalScope(GlobalScope_);
	req->setPartName(PartName_);
	return RemovePartFromPackageMap(req.get());
}

//------ method ValidatePackage ---------

IClientValidatePackageRequest * CClientWsPackageProcess::createValidatePackageRequest()
{
	CValidatePackageRequest* request = new CValidatePackageRequest("WsPackageProcess");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientValidatePackageResponse * CClientWsPackageProcess::ValidatePackage(IClientValidatePackageRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CValidatePackageRequest* esprequest = static_cast<CValidatePackageRequest*>(request);
	CValidatePackageResponse* espresponse = new CValidatePackageResponse("WsPackageProcess");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientWsPackageProcess::async_ValidatePackage(IClientValidatePackageRequest *request, IClientWsPackageProcessEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CValidatePackageRequest* esprequest = static_cast<CValidatePackageRequest*>(request);
	esprequest->setMethod("ValidatePackage");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientWsPackageProcess::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientValidatePackageResponse *CClientWsPackageProcess::ValidatePackageFn(const char * Info_, const char * Target_, const char * Process_, bool Active_, const char * PMID_, const char * QueryIdToVerify_, StringArray &QueriesToVerify_, bool CheckDFS_, bool GlobalScope_)
{
	Owned<IClientValidatePackageRequest> req =  createValidatePackageRequest();
	req->setInfo(Info_);
	req->setTarget(Target_);
	req->setProcess(Process_);
	req->setActive(Active_);
	req->setPMID(PMID_);
	req->setQueryIdToVerify(QueryIdToVerify_);
	req->setQueriesToVerify(QueriesToVerify_);
	req->setCheckDFS(CheckDFS_);
	req->setGlobalScope(GlobalScope_);
	return ValidatePackage(req.get());
}

int CClientWsPackageProcess::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientWsPackageProcessEvents *eventSink = (IClientWsPackageProcessEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "ActivatePackage")==0)
		{
			IClientActivatePackageResponse* icresp = dynamic_cast<IClientActivatePackageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onActivatePackageComplete(icresp, response->queryState());
				else
					eventSink->onActivatePackageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "AddPackage")==0)
		{
			IClientAddPackageResponse* icresp = dynamic_cast<IClientAddPackageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAddPackageComplete(icresp, response->queryState());
				else
					eventSink->onAddPackageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "AddPartToPackageMap")==0)
		{
			IClientAddPartToPackageMapResponse* icresp = dynamic_cast<IClientAddPartToPackageMapResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onAddPartToPackageMapComplete(icresp, response->queryState());
				else
					eventSink->onAddPartToPackageMapError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "CopyPackageMap")==0)
		{
			IClientCopyPackageMapResponse* icresp = dynamic_cast<IClientCopyPackageMapResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onCopyPackageMapComplete(icresp, response->queryState());
				else
					eventSink->onCopyPackageMapError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeActivatePackage")==0)
		{
			IClientDeActivatePackageResponse* icresp = dynamic_cast<IClientDeActivatePackageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeActivatePackageComplete(icresp, response->queryState());
				else
					eventSink->onDeActivatePackageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "DeletePackage")==0)
		{
			IClientDeletePackageResponse* icresp = dynamic_cast<IClientDeletePackageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onDeletePackageComplete(icresp, response->queryState());
				else
					eventSink->onDeletePackageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Echo")==0)
		{
			IClientEchoResponse* icresp = dynamic_cast<IClientEchoResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onEchoComplete(icresp, response->queryState());
				else
					eventSink->onEchoError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetPackage")==0)
		{
			IClientGetPackageResponse* icresp = dynamic_cast<IClientGetPackageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetPackageComplete(icresp, response->queryState());
				else
					eventSink->onGetPackageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetPackageMapById")==0)
		{
			IClientGetPackageMapByIdResponse* icresp = dynamic_cast<IClientGetPackageMapByIdResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetPackageMapByIdComplete(icresp, response->queryState());
				else
					eventSink->onGetPackageMapByIdError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetPackageMapSelectOptions")==0)
		{
			IClientGetPackageMapSelectOptionsResponse* icresp = dynamic_cast<IClientGetPackageMapSelectOptionsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetPackageMapSelectOptionsComplete(icresp, response->queryState());
				else
					eventSink->onGetPackageMapSelectOptionsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetPartFromPackageMap")==0)
		{
			IClientGetPartFromPackageMapResponse* icresp = dynamic_cast<IClientGetPartFromPackageMapResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetPartFromPackageMapComplete(icresp, response->queryState());
				else
					eventSink->onGetPartFromPackageMapError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "GetQueryFileMapping")==0)
		{
			IClientGetQueryFileMappingResponse* icresp = dynamic_cast<IClientGetQueryFileMappingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetQueryFileMappingComplete(icresp, response->queryState());
				else
					eventSink->onGetQueryFileMappingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ListPackage")==0)
		{
			IClientListPackageResponse* icresp = dynamic_cast<IClientListPackageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onListPackageComplete(icresp, response->queryState());
				else
					eventSink->onListPackageError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ListPackages")==0)
		{
			IClientListPackagesResponse* icresp = dynamic_cast<IClientListPackagesResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onListPackagesComplete(icresp, response->queryState());
				else
					eventSink->onListPackagesError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientWsPackageProcessPingResponse* icresp = dynamic_cast<IClientWsPackageProcessPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "RemovePartFromPackageMap")==0)
		{
			IClientRemovePartFromPackageMapResponse* icresp = dynamic_cast<IClientRemovePartFromPackageMapResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onRemovePartFromPackageMapComplete(icresp, response->queryState());
				else
					eventSink->onRemovePartFromPackageMapError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "ValidatePackage")==0)
		{
			IClientValidatePackageResponse* icresp = dynamic_cast<IClientValidatePackageResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onValidatePackageComplete(icresp, response->queryState());
				else
					eventSink->onValidatePackageError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createWsPackageProcessResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "ActivatePackage")==0)
		return new CActivatePackageResponse("WsPackageProcess", request);
	if (stricmp(method, "AddPackage")==0)
		return new CAddPackageResponse("WsPackageProcess", request);
	if (stricmp(method, "AddPartToPackageMap")==0)
		return new CAddPartToPackageMapResponse("WsPackageProcess", request);
	if (stricmp(method, "CopyPackageMap")==0)
		return new CCopyPackageMapResponse("WsPackageProcess", request);
	if (stricmp(method, "DeActivatePackage")==0)
		return new CDeActivatePackageResponse("WsPackageProcess", request);
	if (stricmp(method, "DeletePackage")==0)
		return new CDeletePackageResponse("WsPackageProcess", request);
	if (stricmp(method, "Echo")==0)
		return new CEchoResponse("WsPackageProcess", request);
	if (stricmp(method, "GetPackage")==0)
		return new CGetPackageResponse("WsPackageProcess", request);
	if (stricmp(method, "GetPackageMapById")==0)
		return new CGetPackageMapByIdResponse("WsPackageProcess", request);
	if (stricmp(method, "GetPackageMapSelectOptions")==0)
		return new CGetPackageMapSelectOptionsResponse("WsPackageProcess", request);
	if (stricmp(method, "GetPartFromPackageMap")==0)
		return new CGetPartFromPackageMapResponse("WsPackageProcess", request);
	if (stricmp(method, "GetQueryFileMapping")==0)
		return new CGetQueryFileMappingResponse("WsPackageProcess", request);
	if (stricmp(method, "ListPackage")==0)
		return new CListPackageResponse("WsPackageProcess", request);
	if (stricmp(method, "ListPackages")==0)
		return new CListPackagesResponse("WsPackageProcess", request);
	if (stricmp(method, "Ping")==0)
		return new CWsPackageProcessPingResponse("WsPackageProcess", request);
	if (stricmp(method, "RemovePartFromPackageMap")==0)
		return new CRemovePartFromPackageMapResponse("WsPackageProcess", request);
	if (stricmp(method, "ValidatePackage")==0)
		return new CValidatePackageResponse("WsPackageProcess", request);
	return NULL;
}

#ifdef _WIN32
void CClientWsPackageProcess::espWorkerThread(void* data)
#else
void *CClientWsPackageProcess::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createWsPackageProcessResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientWsPackageProcess::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientWsPackageProcess * createWsPackageProcessClient() {  return new CClientWsPackageProcess(); }


#endif //ws_packageprocess_ESPGEN_INCLUDED
