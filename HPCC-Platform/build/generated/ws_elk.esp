// *** Source file generated by HIDL Version 1.3 from ws_elk.ecm ***
// *** Not to be hand edited (changes will be lost on re-generation) ***

#ifndef ws_elk_ESPGEN_INCLUDED
#define ws_elk_ESPGEN_INCLUDED

#include "ws_elk_esp.ipp"

#ifdef _WIN32
#include "edwin.h"
#include <process.h>
#endif



//=======================================================
// class CGetConfigDetailsRequest Implementation
//=======================================================

CGetConfigDetailsRequest::CGetConfigDetailsRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetConfigDetailsRequest::CGetConfigDetailsRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsRequest");
}

CGetConfigDetailsRequest::CGetConfigDetailsRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetConfigDetailsRequest::CGetConfigDetailsRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetConfigDetailsRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void CGetConfigDetailsRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetConfigDetailsRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetConfigDetailsRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetConfigDetailsRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetConfigDetailsRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void CGetConfigDetailsRequest::copy(CGetConfigDetailsRequest &from)
{
}


void CGetConfigDetailsRequest::copy(IConstGetConfigDetailsRequest &ifrom)
{
}


void CGetConfigDetailsRequest::getAttributes(IProperties &attributes)
{
}


void CGetConfigDetailsRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void CGetConfigDetailsRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetConfigDetailsRequest::serializer(IEspContext* ctx, IConstGetConfigDetailsRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetConfigDetailsRequest>");
	if (keepRootTag)
		buffer.append("</GetConfigDetailsRequest>");
}

bool CGetConfigDetailsRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool CGetConfigDetailsRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool CGetConfigDetailsRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspGetConfigDetailsRequest *createGetConfigDetailsRequest(const char *serv){return ((IEspGetConfigDetailsRequest *)new CGetConfigDetailsRequest(serv));}
extern "C"  IClientGetConfigDetailsRequest *createClientGetConfigDetailsRequest(const char *serv){return ((IClientGetConfigDetailsRequest *)new CGetConfigDetailsRequest(serv));}

//=======================================================
// class CGetConfigDetailsResponse Implementation
//=======================================================

CGetConfigDetailsResponse::CGetConfigDetailsResponse(const char *serviceName, IRpcMessageBinding *init)
	: m_IntegrateKibana(nilIgnore),m_KibanaAddress(nilIgnore),m_KibanaPort(nilIgnore),m_KibanaEntryPointURI(nilIgnore),m_ReportElasticSearchHealth(nilIgnore),m_ElasticSearchAddresses(nilIgnore),m_ElasticSearchPort(nilIgnore),m_ReportLogStashHealth(nilIgnore),m_LogStashAddress(nilIgnore),m_LogStashPort(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

CGetConfigDetailsResponse::CGetConfigDetailsResponse(const char *serviceName, const char *bc)
	: m_IntegrateKibana(nilIgnore),m_KibanaAddress(nilIgnore),m_KibanaPort(nilIgnore),m_KibanaEntryPointURI(nilIgnore),m_ReportElasticSearchHealth(nilIgnore),m_ElasticSearchAddresses(nilIgnore),m_ElasticSearchPort(nilIgnore),m_ReportLogStashHealth(nilIgnore),m_LogStashAddress(nilIgnore),m_LogStashPort(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsResponse");
}

CGetConfigDetailsResponse::CGetConfigDetailsResponse(const char *serviceName, IRpcMessage* rpcmsg)
	: m_IntegrateKibana(nilIgnore),m_KibanaAddress(nilIgnore),m_KibanaPort(nilIgnore),m_KibanaEntryPointURI(nilIgnore),m_ReportElasticSearchHealth(nilIgnore),m_ElasticSearchAddresses(nilIgnore),m_ElasticSearchPort(nilIgnore),m_ReportLogStashHealth(nilIgnore),m_LogStashAddress(nilIgnore),m_LogStashPort(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

CGetConfigDetailsResponse::CGetConfigDetailsResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
	: m_IntegrateKibana(nilIgnore),m_KibanaAddress(nilIgnore),m_KibanaPort(nilIgnore),m_KibanaEntryPointURI(nilIgnore),m_ReportElasticSearchHealth(nilIgnore),m_ElasticSearchAddresses(nilIgnore),m_ElasticSearchPort(nilIgnore),m_ReportLogStashHealth(nilIgnore),m_LogStashAddress(nilIgnore),m_LogStashPort(nilIgnore)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("GetConfigDetailsResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &CGetConfigDetailsResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType>\n", msgTypeName);
		}
		if (!(flags & 0x10)) {
			schema.append("<xsd:all>");
		}
		schema.append("<xsd:element minOccurs=\"0\" name=\"IntegrateKibana\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"KibanaAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"KibanaPort\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"KibanaEntryPointURI\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReportElasticSearchHealth\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ElasticSearchAddresses\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ElasticSearchPort\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"ReportLogStashHealth\" type=\"xsd:boolean\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogStashAddress\" type=\"xsd:string\"/>\n");
		schema.append("<xsd:element minOccurs=\"0\" name=\"LogStashPort\" type=\"xsd:string\"/>\n");
		if (!(flags & 0x10))
			schema.append("</xsd:all>\n");
		if (flags & 0x01) {
			schema.append("</xsd:complexType></xsd:element>\n");
		}
	}
	return schema;
}

void CGetConfigDetailsResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void CGetConfigDetailsResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &CGetConfigDetailsResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("IntegrateKibana");
	
	form.appendf("  <tr><td><b>IntegrateKibana? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("KibanaAddress");
	form.appendf("  <tr><td><b>KibanaAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("KibanaPort");
	form.appendf("  <tr><td><b>KibanaPort: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("KibanaEntryPointURI");
	form.appendf("  <tr><td><b>KibanaEntryPointURI: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReportElasticSearchHealth");
	
	form.appendf("  <tr><td><b>ReportElasticSearchHealth? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ElasticSearchAddresses");
	form.appendf("  <tr><td><b>ElasticSearchAddresses: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ElasticSearchPort");
	form.appendf("  <tr><td><b>ElasticSearchPort: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("ReportLogStashHealth");
	
	form.appendf("  <tr><td><b>ReportLogStashHealth? </b></td><td><input type=\"checkbox\" name=\"%s\" value=\"1\"  /></td></tr>\n", extfix.str());
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogStashAddress");
	form.appendf("  <tr><td><b>LogStashAddress: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	extfix.clear();
	if (prefix && *prefix)
		extfix.append(prefix).append(".");
	extfix.append("LogStashPort");
	form.appendf("  <tr><td><b>LogStashPort: </b></td><td><input type=\"text\" name=\"%s\" size=\"50\" value=\"\" />", extfix.str());
	form.append("</td></tr>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &CGetConfigDetailsResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void CGetConfigDetailsResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
		m_IntegrateKibana.marshall(rpc_resp, "IntegrateKibana", "", "", "");
		m_KibanaAddress.marshall(rpc_resp, "KibanaAddress", "", "", "");
		m_KibanaPort.marshall(rpc_resp, "KibanaPort", "", "", "");
		m_KibanaEntryPointURI.marshall(rpc_resp, "KibanaEntryPointURI", "", "", "");
		m_ReportElasticSearchHealth.marshall(rpc_resp, "ReportElasticSearchHealth", "", "", "");
		m_ElasticSearchAddresses.marshall(rpc_resp, "ElasticSearchAddresses", "", "", "");
		m_ElasticSearchPort.marshall(rpc_resp, "ElasticSearchPort", "", "", "");
		m_ReportLogStashHealth.marshall(rpc_resp, "ReportLogStashHealth", "", "", "");
		m_LogStashAddress.marshall(rpc_resp, "LogStashAddress", "", "", "");
		m_LogStashPort.marshall(rpc_resp, "LogStashPort", "", "", "");
	}
}


void CGetConfigDetailsResponse::copy(CGetConfigDetailsResponse &from)
{
	m_IntegrateKibana.copy(from.m_IntegrateKibana);
	m_KibanaAddress.copy(from.m_KibanaAddress);
	m_KibanaPort.copy(from.m_KibanaPort);
	m_KibanaEntryPointURI.copy(from.m_KibanaEntryPointURI);
	m_ReportElasticSearchHealth.copy(from.m_ReportElasticSearchHealth);
	m_ElasticSearchAddresses.copy(from.m_ElasticSearchAddresses);
	m_ElasticSearchPort.copy(from.m_ElasticSearchPort);
	m_ReportLogStashHealth.copy(from.m_ReportLogStashHealth);
	m_LogStashAddress.copy(from.m_LogStashAddress);
	m_LogStashPort.copy(from.m_LogStashPort);
}


void CGetConfigDetailsResponse::copy(IConstGetConfigDetailsResponse &ifrom)
{
	setIntegrateKibana(ifrom.getIntegrateKibana());
	setKibanaAddress(ifrom.getKibanaAddress());
	setKibanaPort(ifrom.getKibanaPort());
	setKibanaEntryPointURI(ifrom.getKibanaEntryPointURI());
	setReportElasticSearchHealth(ifrom.getReportElasticSearchHealth());
	setElasticSearchAddresses(ifrom.getElasticSearchAddresses());
	setElasticSearchPort(ifrom.getElasticSearchPort());
	setReportLogStashHealth(ifrom.getReportLogStashHealth());
	setLogStashAddress(ifrom.getLogStashAddress());
	setLogStashPort(ifrom.getLogStashPort());
}


void CGetConfigDetailsResponse::getAttributes(IProperties &attributes)
{
}


void CGetConfigDetailsResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
		m_IntegrateKibana.toStr(ctx, buffer, "IntegrateKibana", "", true, "", "");
		m_KibanaAddress.toStr(ctx, buffer, "KibanaAddress", "", true, "", "");
		m_KibanaPort.toStr(ctx, buffer, "KibanaPort", "", true, "", "");
		m_KibanaEntryPointURI.toStr(ctx, buffer, "KibanaEntryPointURI", "", true, "", "");
		m_ReportElasticSearchHealth.toStr(ctx, buffer, "ReportElasticSearchHealth", "", true, "", "");
		m_ElasticSearchAddresses.toStr(ctx, buffer, "ElasticSearchAddresses", "", true, "", "");
		m_ElasticSearchPort.toStr(ctx, buffer, "ElasticSearchPort", "", true, "", "");
		m_ReportLogStashHealth.toStr(ctx, buffer, "ReportLogStashHealth", "", true, "", "");
		m_LogStashAddress.toStr(ctx, buffer, "LogStashAddress", "", true, "", "");
		m_LogStashPort.toStr(ctx, buffer, "LogStashPort", "", true, "", "");
	}
}


void CGetConfigDetailsResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void CGetConfigDetailsResponse::serializer(IEspContext* ctx, IConstGetConfigDetailsResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<GetConfigDetailsResponse>");
	// field IntegrateKibana
	{
		bool b = src.getIntegrateKibana();
		if (b)
			buffer.appendf("<IntegrateKibana>1</IntegrateKibana>");
	}
	// field KibanaAddress
	{
		const char* s = src.getKibanaAddress();
		if (s && *s)
		{
			buffer.append("<KibanaAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</KibanaAddress>");
		}
	}
	// field KibanaPort
	{
		const char* s = src.getKibanaPort();
		if (s && *s)
		{
			buffer.append("<KibanaPort>");
			encodeUtf8XML(s,buffer);
			buffer.append("</KibanaPort>");
		}
	}
	// field KibanaEntryPointURI
	{
		const char* s = src.getKibanaEntryPointURI();
		if (s && *s)
		{
			buffer.append("<KibanaEntryPointURI>");
			encodeUtf8XML(s,buffer);
			buffer.append("</KibanaEntryPointURI>");
		}
	}
	// field ReportElasticSearchHealth
	{
		bool b = src.getReportElasticSearchHealth();
		if (b)
			buffer.appendf("<ReportElasticSearchHealth>1</ReportElasticSearchHealth>");
	}
	// field ElasticSearchAddresses
	{
		const char* s = src.getElasticSearchAddresses();
		if (s && *s)
		{
			buffer.append("<ElasticSearchAddresses>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ElasticSearchAddresses>");
		}
	}
	// field ElasticSearchPort
	{
		const char* s = src.getElasticSearchPort();
		if (s && *s)
		{
			buffer.append("<ElasticSearchPort>");
			encodeUtf8XML(s,buffer);
			buffer.append("</ElasticSearchPort>");
		}
	}
	// field ReportLogStashHealth
	{
		bool b = src.getReportLogStashHealth();
		if (b)
			buffer.appendf("<ReportLogStashHealth>1</ReportLogStashHealth>");
	}
	// field LogStashAddress
	{
		const char* s = src.getLogStashAddress();
		if (s && *s)
		{
			buffer.append("<LogStashAddress>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogStashAddress>");
		}
	}
	// field LogStashPort
	{
		const char* s = src.getLogStashPort();
		if (s && *s)
		{
			buffer.append("<LogStashPort>");
			encodeUtf8XML(s,buffer);
			buffer.append("</LogStashPort>");
		}
	}
	if (keepRootTag)
		buffer.append("</GetConfigDetailsResponse>");
}

bool CGetConfigDetailsResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
		hasValue |= m_IntegrateKibana.unmarshall(rpc_request, "IntegrateKibana", basepath);
		hasValue |= m_KibanaAddress.unmarshall(rpc_request, "KibanaAddress", basepath);
		hasValue |= m_KibanaPort.unmarshall(rpc_request, "KibanaPort", basepath);
		hasValue |= m_KibanaEntryPointURI.unmarshall(rpc_request, "KibanaEntryPointURI", basepath);
		hasValue |= m_ReportElasticSearchHealth.unmarshall(rpc_request, "ReportElasticSearchHealth", basepath);
		hasValue |= m_ElasticSearchAddresses.unmarshall(rpc_request, "ElasticSearchAddresses", basepath);
		hasValue |= m_ElasticSearchPort.unmarshall(rpc_request, "ElasticSearchPort", basepath);
		hasValue |= m_ReportLogStashHealth.unmarshall(rpc_request, "ReportLogStashHealth", basepath);
		hasValue |= m_LogStashAddress.unmarshall(rpc_request, "LogStashAddress", basepath);
		hasValue |= m_LogStashPort.unmarshall(rpc_request, "LogStashPort", basepath);
	}
	return hasValue;
}

bool CGetConfigDetailsResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	hasValue |= m_IntegrateKibana.unmarshall(ctx, soapval, "IntegrateKibana");
	hasValue |= m_KibanaAddress.unmarshall(ctx, soapval, "KibanaAddress");
	hasValue |= m_KibanaPort.unmarshall(ctx, soapval, "KibanaPort");
	hasValue |= m_KibanaEntryPointURI.unmarshall(ctx, soapval, "KibanaEntryPointURI");
	hasValue |= m_ReportElasticSearchHealth.unmarshall(ctx, soapval, "ReportElasticSearchHealth");
	hasValue |= m_ElasticSearchAddresses.unmarshall(ctx, soapval, "ElasticSearchAddresses");
	hasValue |= m_ElasticSearchPort.unmarshall(ctx, soapval, "ElasticSearchPort");
	hasValue |= m_ReportLogStashHealth.unmarshall(ctx, soapval, "ReportLogStashHealth");
	hasValue |= m_LogStashAddress.unmarshall(ctx, soapval, "LogStashAddress");
	hasValue |= m_LogStashPort.unmarshall(ctx, soapval, "LogStashPort");
	return hasValue;
}

bool CGetConfigDetailsResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	hasValue |= m_IntegrateKibana.unmarshall(ctx, params, attachments, "IntegrateKibana", basepath);
	hasValue |= m_KibanaAddress.unmarshall(ctx, params, attachments, "KibanaAddress", basepath);
	hasValue |= m_KibanaPort.unmarshall(ctx, params, attachments, "KibanaPort", basepath);
	hasValue |= m_KibanaEntryPointURI.unmarshall(ctx, params, attachments, "KibanaEntryPointURI", basepath);
	hasValue |= m_ReportElasticSearchHealth.unmarshall(ctx, params, attachments, "ReportElasticSearchHealth", basepath);
	hasValue |= m_ElasticSearchAddresses.unmarshall(ctx, params, attachments, "ElasticSearchAddresses", basepath);
	hasValue |= m_ElasticSearchPort.unmarshall(ctx, params, attachments, "ElasticSearchPort", basepath);
	hasValue |= m_ReportLogStashHealth.unmarshall(ctx, params, attachments, "ReportLogStashHealth", basepath);
	hasValue |= m_LogStashAddress.unmarshall(ctx, params, attachments, "LogStashAddress", basepath);
	hasValue |= m_LogStashPort.unmarshall(ctx, params, attachments, "LogStashPort", basepath);
	return hasValue;
}

bool CGetConfigDetailsResponse::getIntegrateKibana() { return m_IntegrateKibana;}
const char * CGetConfigDetailsResponse::getKibanaAddress() { return m_KibanaAddress.query();}
const char * CGetConfigDetailsResponse::getKibanaPort() { return m_KibanaPort.query();}
const char * CGetConfigDetailsResponse::getKibanaEntryPointURI() { return m_KibanaEntryPointURI.query();}
bool CGetConfigDetailsResponse::getReportElasticSearchHealth() { return m_ReportElasticSearchHealth;}
const char * CGetConfigDetailsResponse::getElasticSearchAddresses() { return m_ElasticSearchAddresses.query();}
const char * CGetConfigDetailsResponse::getElasticSearchPort() { return m_ElasticSearchPort.query();}
bool CGetConfigDetailsResponse::getReportLogStashHealth() { return m_ReportLogStashHealth;}
const char * CGetConfigDetailsResponse::getLogStashAddress() { return m_LogStashAddress.query();}
const char * CGetConfigDetailsResponse::getLogStashPort() { return m_LogStashPort.query();}
void CGetConfigDetailsResponse::setIntegrateKibana(bool val){ m_IntegrateKibana=val; }
void CGetConfigDetailsResponse::setKibanaAddress(const char * val){ m_KibanaAddress.set(val); }
void CGetConfigDetailsResponse::setKibanaPort(const char * val){ m_KibanaPort.set(val); }
void CGetConfigDetailsResponse::setKibanaEntryPointURI(const char * val){ m_KibanaEntryPointURI.set(val); }
void CGetConfigDetailsResponse::setReportElasticSearchHealth(bool val){ m_ReportElasticSearchHealth=val; }
void CGetConfigDetailsResponse::setElasticSearchAddresses(const char * val){ m_ElasticSearchAddresses.set(val); }
void CGetConfigDetailsResponse::setElasticSearchPort(const char * val){ m_ElasticSearchPort.set(val); }
void CGetConfigDetailsResponse::setReportLogStashHealth(bool val){ m_ReportLogStashHealth=val; }
void CGetConfigDetailsResponse::setLogStashAddress(const char * val){ m_LogStashAddress.set(val); }
void CGetConfigDetailsResponse::setLogStashPort(const char * val){ m_LogStashPort.set(val); }
extern "C"  IEspGetConfigDetailsResponse *createGetConfigDetailsResponse(const char *serv){return ((IEspGetConfigDetailsResponse *)new CGetConfigDetailsResponse(serv));}
extern "C"  IClientGetConfigDetailsResponse *createClientGetConfigDetailsResponse(const char *serv){return ((IClientGetConfigDetailsResponse *)new CGetConfigDetailsResponse(serv));}

//=======================================================
// class Cws_elkPingRequest Implementation
//=======================================================

Cws_elkPingRequest::Cws_elkPingRequest(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingRequest");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_elkPingRequest::Cws_elkPingRequest(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingRequest");
}

Cws_elkPingRequest::Cws_elkPingRequest(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingRequest");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_elkPingRequest::Cws_elkPingRequest(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingRequest");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_elkPingRequest::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_elkPingRequest::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_elkPingRequest::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_elkPingRequest::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_elkPingRequest::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_elkPingRequest::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

}


void Cws_elkPingRequest::copy(Cws_elkPingRequest &from)
{
}


void Cws_elkPingRequest::copy(IConstws_elkPingRequest &ifrom)
{
}


void Cws_elkPingRequest::getAttributes(IProperties &attributes)
{
}


void Cws_elkPingRequest::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
}


void Cws_elkPingRequest::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_elkPingRequest::serializer(IEspContext* ctx, IConstws_elkPingRequest &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_elkPingRequest>");
	if (keepRootTag)
		buffer.append("</ws_elkPingRequest>");
}

bool Cws_elkPingRequest::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	return hasValue;
}

bool Cws_elkPingRequest::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_elkPingRequest::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_elkPingRequest *createws_elkPingRequest(const char *serv){return ((IEspws_elkPingRequest *)new Cws_elkPingRequest(serv));}
extern "C"  IClientws_elkPingRequest *createClientws_elkPingRequest(const char *serv){return ((IClientws_elkPingRequest *)new Cws_elkPingRequest(serv));}

//=======================================================
// class Cws_elkPingResponse Implementation
//=======================================================

Cws_elkPingResponse::Cws_elkPingResponse(const char *serviceName, IRpcMessageBinding *init)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingResponse");
	if (init)
	{
		setClientValue(init->getClientValue());
		setReqId(init->getReqId());
		setEventSink(init->getEventSink());
		setState(init->queryState());
		setThunkHandle(init->getThunkHandle());
		setMethod(init->getMethod());
	}
}

Cws_elkPingResponse::Cws_elkPingResponse(const char *serviceName, const char *bc)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingResponse");
}

Cws_elkPingResponse::Cws_elkPingResponse(const char *serviceName, IRpcMessage* rpcmsg)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingResponse");
	unserialize(*rpcmsg,NULL,NULL);
}

Cws_elkPingResponse::Cws_elkPingResponse(IEspContext* ctx, const char *serviceName, IProperties *params, MapStrToBuf *attachments)
{
	m_eventSink=NULL;
	m_RequestState=NULL;
	m_serviceName.append(serviceName);
	m_msgName.append("ws_elkPingResponse");
	unserialize(ctx,*params,attachments, NULL);
}

StringBuffer &Cws_elkPingResponse::getXsdDefinition(IEspContext &context, CHttpRequest* request, const char *msgTypeName, StringBuffer &schema, BoolHash &added, const char *xns, const char *wsns, unsigned flags)
{
	if (!(flags & 0x100))
	{
		IProperties *props = request->queryParameters();
		if(msgTypeName) {
			if(added.getValue(msgTypeName))
				return schema;
			else
				added.setValue(msgTypeName, 1);
		}
		if (flags & 0x01) {
			schema.appendf("<xsd:element name=\"%s\"><xsd:complexType><xsd:all/></xsd:complexType></xsd:element>\n", msgTypeName);
		}
	}
	return schema;
}

void Cws_elkPingResponse::getMapInfo(IMapInfo& info) {  BoolHash added; getMapInfo(info, added); }

void Cws_elkPingResponse::getMapInfo(IMapInfo& info, BoolHash& added)
{
}

StringBuffer &Cws_elkPingResponse::getHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &form, bool includeFormTag, const char *prefix)
{
	IProperties *props = request->queryParameters();
	if (includeFormTag) {
		StringBuffer params, versionTag;
		bool hasVersion = getUrlParams(props,params);
		if (!hasVersion) versionTag.appendf("%cver_=%g",params.length()?'&':'?',context.getClientVersion());
		form.appendf("\n<form name=\"esp_form\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\" action=\"/%s/%s%s%s\">\n", serv, method, params.str(), versionTag.str());
	}
	StringBuffer extfix;
	form.append(" <table>\n");
	if (includeFormTag) {
		form.append("<tr><td></td><td><input type=\"submit\" value=\"Submit\" name=\"S1\" />");
		form.append(" &nbsp; <input type=\"reset\" value=\"Clear\"/> </td> </tr>");
	}
	form.append("</table>");
	if (includeFormTag)
		form.append("</form>");
	return form;
}

StringBuffer &Cws_elkPingResponse::serializeHtml(IEspContext &context, const char *serv, const char *method, StringBuffer &html)
{
	return html;
}

void Cws_elkPingResponse::serialize(IRpcMessage& rpc_resp)
{
	rpc_resp.set_ns("");
	rpc_resp.set_name(m_msgName.str());
	StringBuffer nsuri;
	nsuri.append("urn:hpccsystems:ws:").appendLower(m_serviceName.length(), m_serviceName.str());
	rpc_resp.set_nsuri(nsuri.str());

	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		StringBuffer xml;
		exceptions.serialize(xml, 0, true, false);
		rpc_resp.add_value("", "", "Exceptions", "", xml.str(), false);
	}
	else
	{
	}
}


void Cws_elkPingResponse::copy(Cws_elkPingResponse &from)
{
}


void Cws_elkPingResponse::copy(IConstws_elkPingResponse &ifrom)
{
}


void Cws_elkPingResponse::getAttributes(IProperties &attributes)
{
}


void Cws_elkPingResponse::serializeContent(IEspContext* ctx, StringBuffer& buffer, IProperties **pprops)
{
	const IMultiException& exceptions = getExceptions();
	if (exceptions.ordinality() > 0)
	{
		if(ctx && ctx->getResponseFormat()==ESPSerializationJSON)
			exceptions.serializeJSON(buffer, 0, true);
		else
			exceptions.serialize(buffer, 0, true);
	}
	else
	{
	}
}


void Cws_elkPingResponse::serializeAttributes(IEspContext* ctx, StringBuffer& s)
{
}

void Cws_elkPingResponse::serializer(IEspContext* ctx, IConstws_elkPingResponse &src, StringBuffer& buffer, bool keepRootTag)
{
	if (keepRootTag)
	buffer.append("<ws_elkPingResponse>");
	if (keepRootTag)
		buffer.append("</ws_elkPingResponse>");
}

bool Cws_elkPingResponse::unserialize(IRpcMessage& rpc_request, const char *tagname, const char *basepath)
{
	rpc_request.setEncodeXml(false);
	bool hasValue = false;
	StringBuffer xml;
	rpc_request.get_value("Exceptions", xml, false);

	Owned<IMultiException> me = MakeMultiException();
	if(xml.length() > 0)
		me->deserialize(xml.str());

	if (me->ordinality() > 0 )
	{
		IArrayOf<IException>& exceptions = me->getArray();
		ForEachItemIn(i, exceptions)
			noteException(*LINK(&exceptions.item(i)));
	}
	else
	{
	}
	return hasValue;
}

bool Cws_elkPingResponse::unserialize(IEspContext* ctx, CSoapValue& soapval)
{
	bool hasValue = false;
	return hasValue;
}

bool Cws_elkPingResponse::unserialize(IEspContext* ctx, IProperties& params, MapStrToBuf *attachments, const char *basepath)
{
	bool hasValue = false;
	return hasValue;
}

extern "C"  IEspws_elkPingResponse *createws_elkPingResponse(const char *serv){return ((IEspws_elkPingResponse *)new Cws_elkPingResponse(serv));}
extern "C"  IClientws_elkPingResponse *createClientws_elkPingResponse(const char *serv){return ((IClientws_elkPingResponse *)new Cws_elkPingResponse(serv));}

//=======================================================
// class Cws_elkSoapBinding Implementation
//=======================================================

Cws_elkSoapBinding::Cws_elkSoapBinding(http_soap_log_level level):CHttpSoapBinding(NULL, NULL, NULL, level)
{
	init_strings();
	setWsdlVersion(1);
}

Cws_elkSoapBinding::Cws_elkSoapBinding(IPropertyTree* cfg, const char *bindname, const char *procname, http_soap_log_level level):CHttpSoapBinding(cfg, bindname, procname, level)
{
	init_strings(); 
	setWsdlVersion(1);

}

void Cws_elkSoapBinding::init_strings()
{
}

int Cws_elkSoapBinding::processRequest(IRpcMessage* rpc_call, IRpcMessage* rpc_response)
{
	if(rpc_call == NULL || rpc_response == NULL)
		return -1;

	IEspContext *ctx=rpc_call->queryContext();
	DBGLOG("Client version: %g", ctx->getClientVersion());
	StringBuffer serviceName;
	double clientVer=(ctx) ? ctx->getClientVersion() : 0.0;
	qualifyServiceName(*ctx, ctx->queryServiceName(NULL), NULL, serviceName, NULL);
	CRpcCall* thecall = static_cast<CRpcCall *>(rpc_call);
	CRpcResponse* response = static_cast<CRpcResponse*>(rpc_response);
	CHttpRequest* httprequest = thecall->getHttpReq();
	CHttpResponse* httpresponse = response->getHttpResp();

	Owned<IEspws_elk> iserv = (IEspws_elk*)getService();
	if(iserv == NULL)
	{
		response->set_status(SOAP_SERVER_ERROR);
		response->set_err("Service not available");
		DBGLOG("Service not available");
		return -1;
	}
	if (thecall->get_name() == NULL)
	{
		response->set_status(SOAP_CLIENT_ERROR);
		response->set_err("No service method specified");
		ERRLOG("No service method specified");
		return -1;
	}

	IEspContext& context = *rpc_call->queryContext();

	if(!stricmp(thecall->get_name(), "GetConfigDetails")||!stricmp(thecall->get_name(), "GetConfigDetailsRequest"))
	{
		Owned<CGetConfigDetailsRequest> esp_request = new CGetConfigDetailsRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<CGetConfigDetailsResponse> esp_response = new CGetConfigDetailsResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsELKAccess", SecAccess_Access);
		accessmap.setValue("WsELKAccess", SecAccess_Read);
		StringBuffer source;
		source.appendf("ws_elk::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_elk", "GetConfigDetails");
			iserv->onGetConfigDetails(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_elk", "GetConfigDetails");
		response->set_name("GetConfigDetailsResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	if(!stricmp(thecall->get_name(), "Ping")||!stricmp(thecall->get_name(), "ws_elkPingRequest"))
	{
		Owned<Cws_elkPingRequest> esp_request = new Cws_elkPingRequest(serviceName.str(), thecall);
		checkRequest(context);
		Owned<Cws_elkPingResponse> esp_response = new Cws_elkPingResponse(serviceName.str());
		MapStringTo<SecAccessFlags> accessmap;
		accessmap.setValue("WsELKAccess", SecAccess_Access);
		StringBuffer source;
		source.appendf("ws_elk::%s()", thecall->get_name());
		Owned<IMultiException> me = MakeMultiException(source.str());
		try
		{
			response->set_status(SOAP_OK);
			if( accessmap.ordinality() > 0 )
				onFeaturesAuthorize(context, accessmap, "ws_elk", "Ping");
			iserv->onPing(context, *esp_request, *esp_response);
		}
		catch (IMultiException* mex)
		{
			me->append(*mex);
			mex->Release();
		}
		catch (IException* e)
		{
			me->append(*e);
		}
		catch (...)
		{
			me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
		}
		esp_response->handleExceptions(me, "ws_elk", "Ping");
		response->set_name("ws_elkPingResponse");
		if(!httprequest || !httpresponse)
		{
			esp_response->serialize(*response);
		}
		else
		{
			MemoryBuffer content;
			StringBuffer mimetype;
			esp_response->appendContent(&context,content, mimetype);
			onBeforeSendResponse(context,httprequest,content,serviceName.str(),thecall->get_name());
			httpresponse->setContent(content.length(), content.toByteArray());
			httpresponse->setContentType(mimetype.str());
			httpresponse->send();
			httpresponse->setRespSent(true);
		}
		return 0;
	}

	response->set_status(SOAP_CLIENT_ERROR);
	StringBuffer msg, svcName;
	msg.appendf("Method %s not available in service %s",thecall->get_name(),getServiceName(svcName).str());
	ERRLOG("%s", msg.str());
	response->set_err(msg);
	return -1;
}

int Cws_elkSoapBinding::getXsdDefinition(IEspContext &context, CHttpRequest* request, StringBuffer &content, const char *service, const char *method, bool mda)
{
	BoolHash added;
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	DBGLOG("Client version: %g", context.getClientVersion());
	bool fullservice = (!Utils::strcasecmp(service, "ws_elk"));
	bool allMethods = (method==NULL || *method==0);
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "GetConfigDetails"))) || Utils::strcasecmp(method, "GetConfigDetails")==0)
	{
		CGetConfigDetailsRequest::getMapInfo(context.queryMapInfo());
		CGetConfigDetailsResponse::getMapInfo(context.queryMapInfo());
		CGetConfigDetailsRequest::getXsdDefinition(context, request, "GetConfigDetailsRequest", content, added);
		CGetConfigDetailsResponse::getXsdDefinition(context, request, content, added);
	}
	if ((allMethods&&(fullservice||isMethodInSubService(context, service, "Ping"))) || Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_elkPingRequest::getMapInfo(context.queryMapInfo());
		Cws_elkPingResponse::getMapInfo(context.queryMapInfo());
		Cws_elkPingRequest::getXsdDefinition(context, request, "ws_elkPingRequest", content, added);
		Cws_elkPingResponse::getXsdDefinition(context, request, content, added);
	}
	return 0;
}

int Cws_elkSoapBinding::getMethodHtmlForm(IEspContext &context, CHttpRequest* request, const char *serv, const char *method, StringBuffer &page, bool bIncludeFormTag)
{
	DBGLOG("Client version: %g", context.getClientVersion());
	if (Utils::strcasecmp(method, "GetConfigDetails")==0)
	{
		CGetConfigDetailsRequest::getHtmlForm(context, request, serv, method, page);
	}
	if (Utils::strcasecmp(method, "Ping")==0)
	{
		Cws_elkPingRequest::getHtmlForm(context, request, serv, method, page);
	}
	return 0;
}

int Cws_elkSoapBinding::getQualifiedNames(IEspContext& ctx, MethodInfoArray & methods)
{
	double ver = ctx.getClientVersion();
	if (ver<=0)
		ver = getWsdlVersion();
	const char *servname=ctx.queryServiceName(NULL);
	bool fullservice = (!stricmp(servname, "esp")||!stricmp(servname, "ws_elk"));
	if ((fullservice || isMethodInSubService(ctx, servname, "GetConfigDetails")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("GetConfigDetails", "GetConfigDetailsRequest", "GetConfigDetailsResponse"));
	if ((fullservice || isMethodInSubService(ctx, servname, "Ping")) && ctx.isMethodAllowed(ver,NULL, NULL, -1, -1))
		methods.append(*new CMethodInfo("Ping", "ws_elkPingRequest", "ws_elkPingResponse"));
	return methods.ordinality();
}

StringBuffer & Cws_elkSoapBinding::getServiceName(StringBuffer &resp)
{
	resp.append("ws_elk");
	return resp;
}

bool Cws_elkSoapBinding::isValidServiceName(IEspContext &context, const char *name)
{
	if (!Utils::strcasecmp(name, "ws_elk"))
		return true;
	else
		return (hasSubService(context, name));
}

bool Cws_elkSoapBinding::qualifyMethodName(IEspContext &context, const char *methname, StringBuffer *methQName)
{
	if (!methname || !*methname)
	{
		if (methQName!=NULL)
			methQName->clear();
		return true;
	}
	if (Utils::strcasecmp(methname, "GetConfigDetails")==0)
	{
		if (methQName!=NULL)
			methQName->set("GetConfigDetails");
		return true;
	}
	if (Utils::strcasecmp(methname, "Ping")==0)
	{
		if (methQName!=NULL)
			methQName->set("Ping");
		return true;
	}
	return false;
}

bool Cws_elkSoapBinding::qualifyServiceName(IEspContext &context, const char *servname, const char *methname, StringBuffer &servQName, StringBuffer *methQName)
{
	servQName.clear();
	if (!Utils::strcasecmp(servname, "ws_elk"))
	{
		servQName.append("ws_elk");
		return qualifyMethodName(context, methname, methQName);
	}
	return qualifySubServiceName(context, servname, methname, servQName, methQName);
}

int Cws_elkSoapBinding::onGetFile(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	StringBuffer mimetype;
	MemoryBuffer content;

	StringBuffer filepath;
	getBaseFilePath(filepath);
	if (strchr("\\/", filepath.charAt(filepath.length()-1))==NULL)
		filepath.append("/");
	filepath.append(pathex);
	response->httpContentFromFile(filepath.str());
	response->send();
	return 0;
}

int Cws_elkSoapBinding::onGetForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	if (!stricmp("GetConfigDetails", method)) {
		CGetConfigDetailsRequest::getMapInfo(context.queryMapInfo());
		CGetConfigDetailsResponse::getMapInfo(context.queryMapInfo());
	}
	if (!stricmp("Ping", method)) {
		Cws_elkPingRequest::getMapInfo(context.queryMapInfo());
		Cws_elkPingResponse::getMapInfo(context.queryMapInfo());
	}

	return EspHttpBinding::onGetForm(context, request, response, service, method);
}
int Cws_elkSoapBinding::onGetXForm(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	return EspHttpBinding::onGetXForm(context, request, response, service, method);
}

int Cws_elkSoapBinding::onGetService(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method, const char *pathex)
{
	if(request == NULL || response == NULL)
		return -1;
	return onGetQuery(context, request, response, service, method);
}

 IRpcRequestBinding *Cws_elkSoapBinding::createReqBinding(IEspContext &context, IHttpMessage *ireq, const char *service, const char *method)
{
	CHttpRequest *request=static_cast<CHttpRequest*>(ireq);
	IProperties *props = (request) ? request->queryParameters() : NULL;

	if (!stricmp(method, "GetConfigDetails") || !stricmp(method, "GetConfigDetailsRequest"))
		return new CGetConfigDetailsRequest(&context, "ws_elk", props, NULL);
	if (!stricmp(method, "Ping") || !stricmp(method, "ws_elkPingRequest"))
		return new Cws_elkPingRequest(&context, "ws_elk", props, NULL);
	return NULL;
}

int Cws_elkSoapBinding::onGetInstantQuery(IEspContext &context, CHttpRequest* request, CHttpResponse* response, const char *service, const char *method)
{
	if (context.getClientVersion()<=0)
		context.setClientVersion(1);

	if(request == NULL || response == NULL)
		return -1;
	StringBuffer respStr;
	Owned<IEspws_elk> iserv = (IEspws_elk*)getService();
	if(iserv == NULL)
	{
		respStr.append("Service not available");
		response->setContent(respStr.str());
		response->setContentType("text/html");
		response->send();
	}
	else
	{
		Owned<CSoapResponseBinding> esp_response;
		StringBuffer source;
		IEspContext& context = *request->queryContext();
		if(!stricmp(method, "GetConfigDetails")||!stricmp(method, "GetConfigDetailsRequest"))
		{
			Owned<CGetConfigDetailsRequest> esp_request = new CGetConfigDetailsRequest(&context, "ws_elk", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			CGetConfigDetailsResponse* resp = new CGetConfigDetailsResponse("ws_elk");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsELKAccess", SecAccess_Access);
			accessmap.setValue("WsELKAccess", SecAccess_Read);
			source.setf("ws_elk::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_elk", "GetConfigDetails");
				iserv->onGetConfigDetails(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_elk", "GetConfigDetails", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}
		if(!stricmp(method, "Ping")||!stricmp(method, "ws_elkPingRequest"))
		{
			Owned<Cws_elkPingRequest> esp_request = new Cws_elkPingRequest(&context, "ws_elk", request->queryParameters(), request->queryAttachments());
			checkRequest(context);
			Cws_elkPingResponse* resp = new Cws_elkPingResponse("ws_elk");
			esp_response.setown(resp);
			MapStringTo<SecAccessFlags> accessmap;
			accessmap.setValue("WsELKAccess", SecAccess_Access);
			source.setf("ws_elk::%s()", method);
			Owned<IMultiException> me = MakeMultiException(source.str());
			try
			{
				if(accessmap.ordinality()>0)
					onFeaturesAuthorize(context, accessmap, "ws_elk", "Ping");
				iserv->onPing(context, *esp_request.get(), *resp);
			}
			catch (IMultiException* mex)
			{
				me->append(*mex);
				mex->Release();
			}
			catch (IException* e)
			{
				me->append(*e);
			}
			catch (...)
			{
				me->append(*MakeStringExceptionDirect(-1, "Unknown Exception"));
			}
			if (response->handleExceptions(xslp, me, "ws_elk", "Ping", StringBuffer(getCFD()).append("xslt/exceptions.xslt").str()))
				return 0;
		}

		if (esp_response.get())
		{
			if (canRedirect(*request) && esp_response->getRedirectUrl() && *esp_response->getRedirectUrl())
				response->redirect(*request, esp_response->getRedirectUrl());
			else
			{
				MemoryBuffer content;
				StringBuffer mimetype;
				esp_response->appendContent(&context,content, mimetype);
				onBeforeSendResponse(context,request,content,service,method);
				response->setContent(content.length(), content.toByteArray());
				response->setContentType(mimetype.str());
				response->send();
			}
			return 0;
		}
	}
	return onGetNotFound(context, request,  response, service);
}





//=======================================================
// client util methods
//=======================================================

//------ method GetConfigDetails ---------

IClientGetConfigDetailsRequest * CClientws_elk::createGetConfigDetailsRequest()
{
	CGetConfigDetailsRequest* request = new CGetConfigDetailsRequest("ws_elk");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientGetConfigDetailsResponse * CClientws_elk::GetConfigDetails(IClientGetConfigDetailsRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetConfigDetailsRequest* esprequest = static_cast<CGetConfigDetailsRequest*>(request);
	CGetConfigDetailsResponse* espresponse = new CGetConfigDetailsResponse("ws_elk");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_elk::async_GetConfigDetails(IClientGetConfigDetailsRequest *request, IClientws_elkEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	CGetConfigDetailsRequest* esprequest = static_cast<CGetConfigDetailsRequest*>(request);
	esprequest->setMethod("GetConfigDetails");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_elk::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientGetConfigDetailsResponse *CClientws_elk::GetConfigDetailsFn()
{
	Owned<IClientGetConfigDetailsRequest> req =  createGetConfigDetailsRequest();
	return GetConfigDetails(req.get());
}

//------ method Ping ---------

IClientws_elkPingRequest * CClientws_elk::createPingRequest()
{
	Cws_elkPingRequest* request = new Cws_elkPingRequest("ws_elk");
	request->setProxyAddress(soap_proxy.str());
	request->setUrl(soap_url.str());
	return request;
}

IClientws_elkPingResponse * CClientws_elk::Ping(IClientws_elkPingRequest *request)
{
	if(soap_url.length()== 0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_elkPingRequest* esprequest = static_cast<Cws_elkPingRequest*>(request);
	Cws_elkPingResponse* espresponse = new Cws_elkPingResponse("ws_elk");

	espresponse->setReqId(soap_reqid++);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword(soap_password.str());
	esprequest->soap_setRealm(soap_realm.str());
	const char *soapaction=(soap_action.length()) ? soap_action.str() : NULL;
	esprequest->post(soap_proxy.str(), soap_url.str(), *espresponse, soapaction);
	return espresponse;
}

void CClientws_elk::async_Ping(IClientws_elkPingRequest *request, IClientws_elkEvents *events,IInterface* state)
{
	if(soap_url.length()==0){ throw MakeStringExceptionDirect(-1, "url not set"); }

	Cws_elkPingRequest* esprequest = static_cast<Cws_elkPingRequest*>(request);
	esprequest->setMethod("Ping");
	esprequest->setReqId(soap_reqid++);
	esprequest->setEventSink(events);
	esprequest->setState(state);
	esprequest->soap_setUserId( soap_userid.str());
	esprequest->soap_setPassword( soap_password.str());
	esprequest->soap_setRealm( soap_realm.str());
#ifdef USE_CLIENT_THREAD
	esprequest->setThunkHandle(GetThunkingHandle());
#endif
	esprequest->Link();

	if(state!=NULL)
		state->Link();

#ifdef _WIN32
	_beginthread(espWorkerThread, 0, (void *)(IRpcRequestBinding *)(esprequest));
#else
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	pthread_attr_setstacksize(&attr, 0x10000);
	ThreadId threadid;
	int status;
	do
	{
		status = pthread_create(&threadid, &attr, CClientws_elk::espWorkerThread, (void *)(IRpcRequestBinding *)(esprequest));
	} while (0 != status && (errno == EINTR));
	if (status) {
		Release();
		throw makeOsException(errno);
	}
#endif
}

IClientws_elkPingResponse *CClientws_elk::PingFn()
{
	Owned<IClientws_elkPingRequest> req =  createPingRequest();
	return Ping(req.get());
}

int CClientws_elk::transferThunkEvent(void *data)
{
	IRpcResponseBinding *response = (IRpcResponseBinding *)data;
	if (response!=NULL)
	{
		IClientws_elkEvents *eventSink = (IClientws_elkEvents *)response->getEventSink();
		response->lock();

		if (stricmp(response->getMethod(), "GetConfigDetails")==0)
		{
			IClientGetConfigDetailsResponse* icresp = dynamic_cast<IClientGetConfigDetailsResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onGetConfigDetailsComplete(icresp, response->queryState());
				else
					eventSink->onGetConfigDetailsError(icresp,response->queryState());
			}
		}
		if (stricmp(response->getMethod(), "Ping")==0)
		{
			IClientws_elkPingResponse* icresp = dynamic_cast<IClientws_elkPingResponse*>(response);
			if (icresp) {
				if (response->getRpcState() == RPC_MESSAGE_OK)
					eventSink->onPingComplete(icresp, response->queryState());
				else
					eventSink->onPingError(icresp,response->queryState());
			}
		}
		response->unlock();
	}
	return 0;
}

static IRpcResponseBinding* createws_elkResponseObject(IRpcRequestBinding *request)
{
	const char* method = request->getMethod();
	if (stricmp(method, "GetConfigDetails")==0)
		return new CGetConfigDetailsResponse("ws_elk", request);
	if (stricmp(method, "Ping")==0)
		return new Cws_elkPingResponse("ws_elk", request);
	return NULL;
}

#ifdef _WIN32
void CClientws_elk::espWorkerThread(void* data)
#else
void *CClientws_elk::espWorkerThread(void *data)
#endif
{
	IRpcRequestBinding *request = (IRpcRequestBinding *) data;

	if (request != NULL)
	{
		request->lock();
		IRpcResponseBinding *response=createws_elkResponseObject(request);
		if (response!=NULL)
		{
			try{
				request->post(*response);
			}
			catch(IException* ex){
				StringBuffer errorStr;
				ex->errorMessage(errorStr);
				ERRLOG("CClientws_elk::espWorkerThread(%s)--Exception caught while posting async request: %s", request->getMethod(), errorStr.str());
				ex->Release();
			}
			catch(...){
				ERRLOG("Unknown exception caught while posting async request");
			}
		}
#ifdef USE_CLIENT_THREAD
		ThunkToClientThread(request->getThunkHandle(), transferThunkEvent, (void *)response);
#else
		transferThunkEvent((void *)response);
#endif
		request->unlock();
		if(request->queryState()!=NULL)
			request->queryState()->Release();

		if(response!=NULL)
			response->Release();

		request->Release();
	}
#if defined(_WIN32)
#else
	return (void *) 0 ;
#endif
}



extern "C" IClientws_elk * createws_elkClient() {  return new CClientws_elk(); }


#endif //ws_elk_ESPGEN_INCLUDED
